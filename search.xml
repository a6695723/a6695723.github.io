<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>javaScript性能优化</title>
      <link href="/2020/06/03/javaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2020/06/03/javaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript性能优化"><a href="#JavaScript性能优化" class="headerlink" title="JavaScript性能优化"></a>JavaScript性能优化</h1><blockquote><p>如何编写高性能的JavaScript</p></blockquote><h1 id="1-什么是性能优化？"><a href="#1-什么是性能优化？" class="headerlink" title="1~什么是性能优化？"></a>1~什么是性能优化？</h1><h2 id="1-1-性能优化介绍"><a href="#1-1-性能优化介绍" class="headerlink" title="1.1~性能优化介绍"></a>1.1~性能优化介绍</h2><ul><li><h5 id="性能优化是不可避免的"><a href="#性能优化是不可避免的" class="headerlink" title="性能优化是不可避免的"></a>性能优化是不可避免的</h5></li><li><h5 id="哪些内容可以看做是性能优化"><a href="#哪些内容可以看做是性能优化" class="headerlink" title="哪些内容可以看做是性能优化"></a>哪些内容可以看做是性能优化</h5><blockquote><p>无处不在的前端性能优化</p></blockquote><ul><li>请求资源时候所用到的网络</li><li>数据的传输方式</li><li>开发使用的框架</li></ul></li><li><h5 id="本章所学习的优化内容："><a href="#本章所学习的优化内容：" class="headerlink" title="本章所学习的优化内容："></a>本章所学习的优化内容：</h5><ul><li><h4 id="JavaScript语言的优化"><a href="#JavaScript语言的优化" class="headerlink" title="JavaScript语言的优化"></a><strong>JavaScript语言的优化</strong></h4><ul><li><h5 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h5></li><li><h5 id="垃圾回收与常见的GC算法"><a href="#垃圾回收与常见的GC算法" class="headerlink" title="垃圾回收与常见的GC算法"></a>垃圾回收与常见的GC算法</h5></li><li><h5 id="V8引擎的垃圾回收"><a href="#V8引擎的垃圾回收" class="headerlink" title="V8引擎的垃圾回收"></a>V8引擎的垃圾回收</h5></li><li><h5 id="Performance工具"><a href="#Performance工具" class="headerlink" title="Performance工具"></a>Performance工具</h5></li><li><h6 id="代码优化实例"><a href="#代码优化实例" class="headerlink" title="代码优化实例"></a>代码优化实例</h6></li></ul></li></ul></li></ul><h1 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2~内存管理"></a>2~内存管理</h1><blockquote><p>善待内存从我做起</p></blockquote><h2 id="2-1-内存管理介绍"><a href="#2-1-内存管理介绍" class="headerlink" title="2.1~内存管理介绍"></a>2.1~内存管理介绍</h2><ul><li>内存：由可读写单元组成，表示一片可以操作空间</li><li><p>管理：人为的取操作一片空间的申请，使用和释放</p></li><li><p>内存管理：开发者主动申请空间，使用空间，释放空间</p></li><li><p>基本的内存管理代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请内存</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用内存, 内存的读写操作</span></span><br><span class="line">obj.name = <span class="string">'abel'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line">obj = <span class="literal">null</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="3-垃圾回收与GC算法"><a href="#3-垃圾回收与GC算法" class="headerlink" title="3~垃圾回收与GC算法"></a>3~垃圾回收与GC算法</h1><blockquote><p>收垃圾的也要好好学算法</p></blockquote><h2 id="3-1-JavaScript中的垃圾回收"><a href="#3-1-JavaScript中的垃圾回收" class="headerlink" title="3.1~JavaScript中的垃圾回收"></a>3.1~JavaScript中的垃圾回收</h2><blockquote><p>对于前端开发者来说：</p><ul><li>JavaScript中的内存管理是自动的</li></ul></blockquote><ul><li><h5 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h5><blockquote><p>划定一个范围，不符合标准的都是垃圾</p></blockquote><ul><li><p>对象不再被<strong>引用</strong>的时候</p></li><li><p>对象不能<strong>从根上访问</strong>到的时候</p><ul><li><p>能访问到的对象被称为<strong>可达对象</strong>（引用，作用域链）</p></li><li><p>可达的标准就是从<strong>根</strong>出发是否能够被找到</p><ul><li>JavaScript中的根就可以理解为是<strong>全局变量对象</strong>(全局执行上下文)</li></ul></li></ul></li></ul></li><li><h5 id="应用与可达对象"><a href="#应用与可达对象" class="headerlink" title="应用与可达对象"></a>应用与可达对象</h5><blockquote><p>模拟一个垃圾的产生</p></blockquote><ul><li><p>图示说明</p><p><img src="https://pics.images.ac.cn/image/5ed78a609c941.htm" alt="可达对象"></p></li><li><p>可达对象代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objGroup</span>(<span class="params">obj1, obj2</span>) </span>&#123;</span><br><span class="line">    obj1.next = obj2</span><br><span class="line">    obj2.prev = obj1</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        o1: obj1,</span><br><span class="line">        o2: obj2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = objGroup(&#123;<span class="attr">name</span>: <span class="string">'obj1'</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'obj2'</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure></li><li><p>分析</p><ul><li>无论是obj还是o1,o2都可以从全局出发访问到</li><li>但是如果置空obj，o1,o2就不再可达，就成为了垃圾</li></ul></li></ul></li></ul><h2 id="3-2-GC算法"><a href="#3-2-GC算法" class="headerlink" title="3.2~GC算法"></a>3.2~GC算法</h2><blockquote><p>GC:垃圾回收机制的简写</p></blockquote><ul><li><h5 id="GC的定义与作用"><a href="#GC的定义与作用" class="headerlink" title="GC的定义与作用"></a>GC的定义与作用</h5><ul><li>GC可以找到内存中的垃圾，并释放和回收空间<ul><li>GC中认定的垃圾<ul><li>程序中不再需要使用的对象</li><li>程序中不能再被访问到的对象</li></ul></li></ul></li></ul></li><li><h5 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h5><ul><li>GC是一种机制，垃圾回收器完成具体的工作</li><li>工作的内容就是查找垃圾释放空间，回收空间</li><li>算法就是工作时查找和回收所遵循的规则</li></ul></li><li><h5 id="常见的GC算法"><a href="#常见的GC算法" class="headerlink" title="常见的GC算法"></a>常见的GC算法</h5><ul><li>引用计数</li><li>标记清除</li><li>标记整理</li><li>分代回收</li></ul></li></ul><h3 id="3-2-1-引用计数算法实现原理"><a href="#3-2-1-引用计数算法实现原理" class="headerlink" title="3.2.1~引用计数算法实现原理"></a>3.2.1~引用计数算法实现原理</h3><ul><li><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><ul><li>设置引用数，判断当前引用是否为0</li></ul></li><li><h5 id="引用计数器"><a href="#引用计数器" class="headerlink" title="引用计数器"></a>引用计数器</h5><ul><li><p>当引用关系改变时修改引用数字</p></li><li><p>引用为0时立即回收</p></li></ul></li><li><h5 id="引用计数算法的优缺点"><a href="#引用计数算法的优缺点" class="headerlink" title="引用计数算法的优缺点"></a>引用计数算法的优缺点</h5><ul><li>优点<ul><li>发现垃圾时立即回收</li><li>最大限度减少程序暂停</li></ul></li><li>缺点<ul><li>无法回收循环引用的对象</li><li>时间，资源开销大</li></ul></li></ul></li><li><h5 id="引用计数的代码实现"><a href="#引用计数的代码实现" class="headerlink" title="引用计数的代码实现"></a>引用计数的代码实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user1 = &#123;<span class="attr">age</span>: <span class="number">11</span>&#125;</span><br><span class="line"><span class="keyword">const</span> user2 = &#123;<span class="attr">age</span>: <span class="number">22</span>&#125;</span><br><span class="line"><span class="keyword">const</span> user3 = &#123;<span class="attr">age</span>: <span class="number">33</span>&#125;</span><br><span class="line"><span class="comment">// 再次引用，引用计数加一</span></span><br><span class="line"><span class="keyword">const</span> nameList = [user1.age, user2.age, user3.age]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> num1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> num2 = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当函数执行完毕之后，内部的值引用为零，即被销毁</span></span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用计数之殇</span></span><br><span class="line"><span class="comment">// 循环引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> obj1 = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> obj2 = &#123;&#125;</span><br><span class="line">    obj1.name = obj2</span><br><span class="line">    obj2.name = obj1</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'从根上找不到，却再局部作用域中有互相的访问'</span></span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-2-标记清除算法实现原理"><a href="#3-2-2-标记清除算法实现原理" class="headerlink" title="3.2.2~标记清除算法实现原理"></a>3.2.2~标记清除算法实现原理</h3><blockquote><p>只标记可达对象， 不可达的都是垃圾</p></blockquote><ul><li><h5 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h5><ul><li>分标记和清除两个阶段完成</li><li>遍历所有对象并标记活动对象</li><li>遍历所有对象清除没有标记的对象</li><li>回收相应的空间</li></ul></li><li><h5 id="标记清除图示"><a href="#标记清除图示" class="headerlink" title="标记清除图示"></a>标记清除图示</h5><p><img src="https://pics.images.ac.cn/image/5ed78a62e9926.html" alt="标记清除图示"></p></li><li><h5 id="标记清除算法的优缺点"><a href="#标记清除算法的优缺点" class="headerlink" title="标记清除算法的优缺点"></a>标记清除算法的优缺点</h5><ul><li><p>优点</p><ul><li>解决了引用计数算法的对象循环引用的回收问题</li></ul></li><li><p>缺点</p><ul><li><p>不会立即回收垃圾对象</p></li><li><p>空间碎片化</p><ul><li><p>由于回收的垃圾对象再地址中是不连续的，所以回收的地址空间也是碎片化的</p></li><li><p>图解</p></li></ul><p><img src="https://pics.images.ac.cn/image/5ed78a6450152.html" alt="空间碎片化"></p></li></ul></li></ul></li></ul><h3 id="3-3-3-标记整理算法"><a href="#3-3-3-标记整理算法" class="headerlink" title="3.3.3~标记整理算法"></a>3.3.3~标记整理算法</h3><blockquote><p>回收垃圾中后也要好好整理空间以便后续的使用</p></blockquote><ul><li><h5 id="标记整理的核心思想"><a href="#标记整理的核心思想" class="headerlink" title="标记整理的核心思想"></a>标记整理的核心思想</h5><ul><li>标记整理可以看做是标记清除的增强</li><li>标记阶段的操作和标记清除一致</li><li>清除阶段会先执行整理，移动对象位置</li></ul></li><li><h5 id="标记整理的优缺点"><a href="#标记整理的优缺点" class="headerlink" title="标记整理的优缺点"></a>标记整理的优缺点</h5><ul><li>优点<ul><li>减少碎片化空间</li></ul></li><li>缺点<ul><li>不会立即回收垃圾对象</li></ul></li></ul></li></ul><h1 id="4-V8引擎"><a href="#4-V8引擎" class="headerlink" title="4~V8引擎"></a>4~V8引擎</h1><blockquote><p>V8是一款主流的JavaScript执行引擎</p></blockquote><ul><li><p>V8的特点</p><ul><li>采用<strong>即时编译</strong></li></ul></li><li><p>源码→机器码</p></li><li><p>内存受限</p><blockquote><p>完全够用，且可以优化垃圾回收</p></blockquote><ul><li>64位：不超过1.5G</li><li>32位：不超过800M</li></ul></li></ul><h2 id="4-1-V8垃圾回收策略"><a href="#4-1-V8垃圾回收策略" class="headerlink" title="4.1~V8垃圾回收策略"></a>4.1~V8垃圾回收策略</h2><blockquote><p>V8对于垃圾的回收，厂房空间受限，新旧存储区采取不同的算法</p></blockquote><ul><li><h5 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h5><ul><li><p>采用分代回收的思想</p><ul><li><p>内存分为<strong>新生代、老生代两个内存空间</strong></p><ul><li>小空间用于存储新生代对象(32M|16M)</li></ul></li></ul></li><li><p>针对不同对象采用不同算法</p></li><li><p>V8垃圾回收图解</p><p>  <img src="https://ae01.alicdn.com/kf/H1cb40dc34e2e4861bbe6669dea5727a8S.jpg" alt="V8垃圾回收图解"></p></li></ul></li><li><h5 id="V8中常用的CG算法"><a href="#V8中常用的CG算法" class="headerlink" title="V8中常用的CG算法"></a>V8中常用的CG算法</h5><ul><li>分代回收</li><li>空间复制</li><li>标记清除</li><li>标记整理</li><li>标记增量</li></ul></li></ul><h2 id="4-2-V8回收新生代对象"><a href="#4-2-V8回收新生代对象" class="headerlink" title="4.2~V8回收新生代对象"></a>4.2~V8回收新生代对象</h2><blockquote><p>针对新生代存储区的垃圾回收操作</p></blockquote><ul><li><h5 id="核心思想-3"><a href="#核心思想-3" class="headerlink" title="核心思想"></a>核心思想</h5><ul><li><p>新生代指的是存活时间较短的对象</p><blockquote><p>例如局部作用域中的对象</p></blockquote></li><li><p>回收过程采用<strong>复制算法+标记整理</strong></p></li><li><p>新生代内存区分为两个等大的空间</p><ul><li><p>使用空间为From，空闲空间为To</p></li><li><p>活动对象存储于From空间</p><blockquote><p>当From空间应用到一定程度，触发GC操作</p></blockquote></li><li><p>标记整理后将活动对象拷贝至To</p><ul><li><p>在拷贝过程中可能出现<strong>晋升</strong></p><blockquote><p>晋升就是将新生代对象移动至老年代</p></blockquote></li><li><p>经过一轮GC还存活的新生代需要晋升</p></li><li>如果To空间的使用率超过25%则本次GC操作的所有活动对象都移动至老生代</li></ul></li><li><p>From与To交换空间完全释放</p><ul><li>这一步将所有的活动对象挪出了from区域，并清空from完成回收</li></ul></li></ul></li></ul></li></ul><h2 id="4-3-V8如何回收老生代对象"><a href="#4-3-V8如何回收老生代对象" class="headerlink" title="4.3~V8如何回收老生代对象"></a>4.3~V8如何回收老生代对象</h2><blockquote><p>老年活动中心的处理</p></blockquote><ul><li><h5 id="核心思想-4"><a href="#核心思想-4" class="headerlink" title="核心思想"></a>核心思想</h5><ul><li><p>老年代对象存放在右侧的老生代区域</p></li><li><p>64位操作系统1.4G，32位操作系统700M</p></li><li><p>老年代对象就是存活时间较长的对象</p><blockquote><p>例如全局对象，闭包</p></blockquote></li><li><p>主要采用标记清除、标记整理、增量标记算法</p><ul><li><p>首先使用标记清除完成垃圾空间的回收(速度第一)</p></li><li><p>采用标记整理进行空间优化</p><blockquote><p>发起晋升的时候，如果出现空间不足，就进行空间优化</p></blockquote></li><li><p>采用增量标记进行效率优化</p></li></ul></li></ul></li><li><h5 id="新老细节对比"><a href="#新老细节对比" class="headerlink" title="新老细节对比"></a>新老细节对比</h5><ul><li><p>新生代区域垃圾回收使用空间换时间</p><ul><li>复制算法，保证空闲空间始终存在，由于空间小，所以很容易就进行复制，从而带来存储速度的提升</li></ul></li><li><p>老生代区域垃圾回收不适合复制算法</p><ul><li><p>空间大，一分为二浪费资源</p></li><li><p>存储资源多，复制得不偿失</p></li></ul></li></ul></li><li><h5 id="标记增量优化"><a href="#标记增量优化" class="headerlink" title="标记增量优化"></a>标记增量优化</h5><ul><li><p>图解</p><p><img src="https://pics.images.ac.cn/image/5ed78a65e7f14.html" alt="标记增量优化"></p></li><li><p>核心理解</p><ul><li>将一整个的垃圾回收操作，拆分为多个小的部分，垃圾回收和程序交替执行<ul><li>使程序执行的时候，划分出一些时间用来进行垃圾回收</li></ul></li></ul></li></ul></li></ul><h1 id="5-Performance工具"><a href="#5-Performance工具" class="headerlink" title="5~Performance工具"></a>5~Performance工具</h1><blockquote><p>GC:</p><ul><li><p>GC的目的就是为了实现内存空间的良性循环</p></li><li><p>良性循环的基石是合理使用</p></li><li><strong>时刻关注</strong>才能确定是否合理</li></ul><p>而Performance就是帮助我们来时刻关注内存变化的</p></blockquote><ul><li><h5 id="通过Performance可以时刻监控内存"><a href="#通过Performance可以时刻监控内存" class="headerlink" title="通过Performance可以时刻监控内存"></a>通过Performance可以时刻监控内存</h5></li><li><h5 id="Performance的使用步骤"><a href="#Performance的使用步骤" class="headerlink" title="Performance的使用步骤"></a>Performance的使用步骤</h5><ul><li>打开浏览器输入目标网址</li><li>进入开发人员工具面板，选择性能</li><li>开启录制功能，访问具体界面</li><li>执行用户行为，一段时间后停止录制</li><li>分析界面中记录的内存信息</li></ul></li></ul><h2 id="5-1-内存问题的体现"><a href="#5-1-内存问题的体现" class="headerlink" title="5.1~内存问题的体现"></a>5.1~内存问题的体现</h2><blockquote><p>问题的定位</p></blockquote><ul><li><h5 id="页面出现延迟加载或经常性暂停"><a href="#页面出现延迟加载或经常性暂停" class="headerlink" title="页面出现延迟加载或经常性暂停"></a>页面出现延迟加载或经常性暂停</h5><ul><li>频繁的垃圾回收操作</li></ul></li><li><h5 id="页面持续性出现糟糕的性能"><a href="#页面持续性出现糟糕的性能" class="headerlink" title="页面持续性出现糟糕的性能"></a>页面持续性出现糟糕的性能</h5><ul><li>内存膨胀</li></ul></li><li><h5 id="页面的性能随时间延长越来越差"><a href="#页面的性能随时间延长越来越差" class="headerlink" title="页面的性能随时间延长越来越差"></a>页面的性能随时间延长越来越差</h5><ul><li>内存泄漏</li></ul></li></ul><h2 id="5-2-监控内存的几种方式"><a href="#5-2-监控内存的几种方式" class="headerlink" title="5.2~监控内存的几种方式"></a>5.2~监控内存的几种方式</h2><blockquote><p>快速判断问题，从而更好的解决问题</p></blockquote><ul><li><h5 id="界定内存问题的标准"><a href="#界定内存问题的标准" class="headerlink" title="界定内存问题的标准"></a>界定内存问题的标准</h5><ul><li>内存泄漏<ul><li>内存使用持续升高</li></ul></li><li>内存膨胀<ul><li>在多数设备上都存在性能问题</li></ul></li><li>频繁的垃圾回收<ul><li>通过内存变化图进行分析</li></ul></li></ul></li><li><h5 id="监控内存的几种方式"><a href="#监控内存的几种方式" class="headerlink" title="监控内存的几种方式"></a>监控内存的几种方式</h5><ul><li>浏览器任务管理器<ul><li><code>shift + esc</code></li></ul></li><li>TimeLine时序图记录</li><li>堆快照查找分离DOM<ul><li>分离DOM就是一种内存泄漏</li></ul></li><li>判断是否存在频繁的垃圾回收<ul><li>通过各种内存走势图判断</li></ul></li></ul></li></ul><h2 id="5-3-任务管理器监控内存"><a href="#5-3-任务管理器监控内存" class="headerlink" title="5.3~任务管理器监控内存"></a>5.3~任务管理器监控内存</h2><blockquote><p>判断问题</p></blockquote><ul><li><p>模拟一个耗时操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> arrList = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://pics.images.ac.cn/image/5ed78a670ae52.html" alt="任务管理器监控内存"></p><h2 id="5-4-TimeLine记录内存"><a href="#5-4-TimeLine记录内存" class="headerlink" title="5.4~TimeLine记录内存"></a>5.4~TimeLine记录内存</h2><blockquote><p>定位问题</p></blockquote><ul><li>根据时序，判断是哪一部分操作引起的内存变化</li></ul><p><img src="https://pics.images.ac.cn/image/5ed78a678740c.html" alt="TimeLine"></p><h2 id="5-5-堆快照查找分离DOM"><a href="#5-5-堆快照查找分离DOM" class="headerlink" title="5.5~堆快照查找分离DOM"></a>5.5~堆快照查找分离DOM</h2><blockquote><p>拍个照片来分析，清空deta</p></blockquote><ul><li><h5 id="什么是分离DOM"><a href="#什么是分离DOM" class="headerlink" title="什么是分离DOM"></a>什么是分离DOM</h5><ul><li>界面元素存活在DOM树上</li><li>垃圾对象时的DOM节点</li><li>分离状态的DOM节点</li></ul></li><li><h5 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h5><p><img src="https://pics.images.ac.cn/image/5ed78a6845e71.html" alt="快照"></p></li></ul><h2 id="5-6-判断是否存在频繁的GC"><a href="#5-6-判断是否存在频繁的GC" class="headerlink" title="5.6~判断是否存在频繁的GC"></a>5.6~判断是否存在频繁的GC</h2><blockquote><p>垃圾回收和应用程序不能同步执行，所以不能太频繁</p></blockquote><ul><li><h5 id="为什么要确定频繁垃圾回收"><a href="#为什么要确定频繁垃圾回收" class="headerlink" title="为什么要确定频繁垃圾回收"></a>为什么要确定频繁垃圾回收</h5><ul><li>GC工作时应用程序时停止的</li><li>频繁且过长的GC会导致应用假死</li><li>用户使用中感知应用卡顿</li></ul></li><li><h5 id="确定频繁-的垃圾回收"><a href="#确定频繁-的垃圾回收" class="headerlink" title="确定频繁 的垃圾回收"></a>确定频繁 的垃圾回收</h5><ul><li>Timeline中频繁的上升下降</li><li>任务管理器中数据频繁的增加减少</li></ul></li></ul><h1 id="6-代码优化"><a href="#6-代码优化" class="headerlink" title="6~代码优化"></a>6~代码优化</h1><blockquote><p>如何写出更好的脚本</p></blockquote><ul><li><p>如何精准测试JavaScript性能</p><ul><li>本质上就是采集大量的执行脚本进行数学统计和分析</li><li>使用基于Benchmark.js的<a href="https://jsperf.com/" target="_blank" rel="noopener">Jsperf</a>完成</li></ul></li><li><p>Jsperf的使用流程</p><ul><li>使用GitHub账户登录</li><li>填写个人信息(非必须)</li><li>填写详细的测试用例信息<ul><li>title</li><li>slug</li></ul></li><li>填写准备代码<ul><li>DOM操作时经常使用</li></ul></li><li><p>填写必要的setup与teardown代码</p></li><li><p>填写测试代码片段</p></li></ul></li></ul><h2 id="6-1-慎用全局变量"><a href="#6-1-慎用全局变量" class="headerlink" title="6.1~慎用全局变量"></a>6.1~慎用全局变量</h2><blockquote><p>不是必须的不用全局变量</p></blockquote><ul><li>全局变量<ul><li>全局变量定义在全局执行上下文，是所有作用域链的顶端<ul><li>作用域链查找是从下往上的，全部都在全局，太耗时间</li></ul></li><li>全局执行上下文一直存在于上下文执行栈，直到程序退出<ul><li>不利于GC工作，影响内存使用</li></ul></li><li>如果某个局部作用域出现了同名变量，则会遮蔽或者污染全局<ul><li>全局的变量，被某个局部作用域做出了修改，不容易确定来源</li></ul></li></ul></li></ul><h2 id="6-2-缓存全局变量"><a href="#6-2-缓存全局变量" class="headerlink" title="6.2~缓存全局变量"></a>6.2~缓存全局变量</h2><blockquote><p>将使用中无法避免的全局变量缓存到局部</p></blockquote><ul><li><p>什么是缓存全局变量</p><ul><li>将需要频繁调用的全局变量赋值给一个局部的新的变量</li></ul></li><li><p>原理：使每次调用全局变量根据作用域链的原理，更近了一点</p></li><li><p>例如</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBtn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">document</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-3-通过原型链新增方法"><a href="#6-3-通过原型链新增方法" class="headerlink" title="6.3~通过原型链新增方法"></a>6.3~通过原型链新增方法</h2><blockquote><p>问题：</p><ul><li>为什么添加的地方不一样，会有性能上的差异？</li></ul></blockquote><ul><li>在原型对象上新增实例对象需要的方法</li><li>原型链上的方法只有一个，所有的实例化对象访问的都是一个内存资源，所以节省内存</li></ul><h2 id="6-4-避开闭包陷阱"><a href="#6-4-避开闭包陷阱" class="headerlink" title="6.4~避开闭包陷阱"></a>6.4~避开闭包陷阱</h2><blockquote><p>开始沉思编程式函数频繁使用的闭包操作是否进入了陷阱？</p></blockquote><ul><li><h5 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h5><ul><li>外部具有指向内部的引用</li><li><p>在’外‘部作用域访问’内‘部作用域的数据</p></li><li><p>例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'abel'</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = foo()</span><br><span class="line">a()</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="关于闭包"><a href="#关于闭包" class="headerlink" title="关于闭包"></a>关于闭包</h5><ul><li>闭包使一种强大的语法</li><li>闭包使用不当很容易出现内存泄漏</li><li>不要为了闭包而闭包</li></ul></li><li><h5 id="闭包的陷阱"><a href="#闭包的陷阱" class="headerlink" title="闭包的陷阱"></a>闭包的陷阱</h5><ul><li><p>重复引用已存在的节点</p></li><li><p>解决方法，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 重复引用了页面中已存在的节点，如果删除了该节点，会因为引用计数的问题，仍然占有内存</span></span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)</span><br><span class="line">    el.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(el, id)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所以需要最后将该引用置位null</span></span><br><span class="line">    el = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="6-5-避免属性访问方法使用"><a href="#6-5-避免属性访问方法使用" class="headerlink" title="6.5~避免属性访问方法使用"></a>6.5~避免属性访问方法使用</h2><blockquote><p>JavaScript中的面向对象有些许不同</p></blockquote><ul><li><h5 id="JavaScript中的面向对象"><a href="#JavaScript中的面向对象" class="headerlink" title="JavaScript中的面向对象"></a>JavaScript中的面向对象</h5><ul><li>js不需要属性的访问方法，所有属性都是外部可见的</li><li>使用属性访问方法只会增加一层重定义，没有访问的控制力</li></ul></li></ul><h2 id="6-6-For循环优化"><a href="#6-6-For循环优化" class="headerlink" title="6.6~For循环优化"></a>6.6~For循环优化</h2><blockquote><p>for循环的正确打开方式</p></blockquote><ul><li><h5 id="声明长度，避免重复获取"><a href="#声明长度，避免重复获取" class="headerlink" title="声明长度，避免重复获取"></a>声明长度，避免重复获取</h5></li><li><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-7-选择最优的循环方法"><a href="#6-7-选择最优的循环方法" class="headerlink" title="6.7~选择最优的循环方法"></a>6.7~选择最优的循环方法</h2><blockquote><p>循环方法的优胜略汰，强弱领域判断</p></blockquote><ul><li><h5 id="有图有真相，遍历同一组数组"><a href="#有图有真相，遍历同一组数组" class="headerlink" title="有图有真相，遍历同一组数组"></a>有图有真相，遍历同一组数组</h5></li></ul><p><img src="https://pics.images.ac.cn/image/5ed78a68aa24f.html" alt="性能排序"></p><ul><li><h5 id="性能排序：foreach-gt-for-gt-forin"><a href="#性能排序：foreach-gt-for-gt-forin" class="headerlink" title="性能排序：foreach &gt; for &gt; forin"></a>性能排序：foreach &gt; for &gt; forin</h5></li></ul><h2 id="6-8-节点添加优化"><a href="#6-8-节点添加优化" class="headerlink" title="6.8~节点添加优化"></a>6.8~节点添加优化</h2><blockquote><p>节点的添加操作必然会有回流和重绘</p><p>如何优化，就是针对这两者进行的优化</p></blockquote><ul><li><h5 id="文档碎片优化节点添加"><a href="#文档碎片优化节点添加" class="headerlink" title="文档碎片优化节点添加"></a>文档碎片优化节点添加</h5><blockquote><p>在循环中不直接向页面中的元素添加元素，而是通过一个中间元素容器，组合文档碎片在循环结束后统一添加</p></blockquote> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fragEle = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> op = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>)</span><br><span class="line">    oP.innerHTML = i</span><br><span class="line">    fragEle.appendChild(oP)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(fragEle)</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-9-克隆优化节点操作"><a href="#6-9-克隆优化节点操作" class="headerlink" title="6.9~克隆优化节点操作"></a>6.9~克隆优化节点操作</h2><blockquote><p>生的没有克隆的快</p></blockquote><ul><li><p>需要循环多次创建同一元素的话，可以先创建一个，其余的克隆</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oldP = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> newP = oldP.cloneNode(<span class="literal">false</span>)</span><br><span class="line">    newP.innerHTML = i</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(newP)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-10-直接量替换new-object操作"><a href="#6-10-直接量替换new-object操作" class="headerlink" title="6.10~直接量替换new object操作"></a>6.10~直接量替换new object操作</h2><blockquote><p>优先使用字面量，方便快捷还又好</p></blockquote><ul><li>请使用字面量声明变量</li></ul>]]></content>
      
      
      <categories>
          
          <category> 拉钩大前端学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程规范</title>
      <link href="/2020/06/03/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
      <url>/2020/06/03/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="1-认识函数式编程"><a href="#1-认识函数式编程" class="headerlink" title="1~认识函数式编程"></a>1~认识函数式编程</h1><blockquote><p>问题：</p><ul><li>什么是函数式编程？</li><li>为什么要学习函数式编程？</li></ul></blockquote><h2 id="1-1-函数式编程的概念"><a href="#1-1-函数式编程的概念" class="headerlink" title="1.1~函数式编程的概念"></a>1.1~函数式编程的概念</h2><ul><li><h5 id="函数式编程英文名称"><a href="#函数式编程英文名称" class="headerlink" title="函数式编程英文名称"></a>函数式编程英文名称</h5><ul><li>全称：Functional Programming</li><li>简称：FP</li></ul></li><li><h5 id="简介：一种编程规范"><a href="#简介：一种编程规范" class="headerlink" title="简介：一种编程规范"></a>简介：一种编程规范</h5><ul><li><p>其他的编程规范</p><ul><li>面向过程编程：就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</li><li>面向对象编程：是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</li></ul></li><li><p>函数式编程的规范内容</p><blockquote><p><a href="https://baike.baidu.com/item/函数式编程" target="_blank" rel="noopener">百度百科定义</a></p></blockquote><ul><li><strong>把运算过程尽量写成一系列嵌套的函数调用。</strong></li></ul></li></ul></li><li><h5 id="函数式编程的特性"><a href="#函数式编程的特性" class="headerlink" title="函数式编程的特性"></a>函数式编程的特性</h5><ul><li>纯函数</li><li>柯里化</li><li>函数组合</li></ul></li><li><h5 id="函数式编程库"><a href="#函数式编程库" class="headerlink" title="函数式编程库"></a>函数式编程库</h5><ul><li><a href="https://www.lodashjs.com/" target="_blank" rel="noopener">Lodash</a></li><li><a href="https://folktale.origamitower.com/" target="_blank" rel="noopener">Folktale</a></li><li>…</li></ul></li><li><h5 id="函数式编程的优点"><a href="#函数式编程的优点" class="headerlink" title="函数式编程的优点"></a>函数式编程的优点</h5><ul><li><p>优化杂乱无章的数据操作过程</p><ul><li><p>语义更加清晰</p></li><li><p>可复用性高</p></li><li>可维护性更好</li></ul></li><li><p>优化打包过程</p></li><li><p>优化测试</p><ul><li>组合函数的调试，可以精准的帮助我们找到错误</li></ul></li><li><p>优化并行处理</p><ul><li>作用域局限，副作用少，没有冲突变量</li></ul></li></ul></li></ul><h1 id="2-函数相关复习"><a href="#2-函数相关复习" class="headerlink" title="2~函数相关复习"></a>2~函数相关复习</h1><blockquote><p>学习函数式编程应该具备的前置知识</p><ul><li>函数是一等公民</li><li>高阶函数</li><li>闭包</li></ul></blockquote><h2 id="2-1-函数是一等公民"><a href="#2-1-函数是一等公民" class="headerlink" title="2.1~函数是一等公民"></a>2.1~函数是一等公民</h2><blockquote><p>问题：</p><ul><li>什么是一等公民？</li><li>函数是一等公民意味着什么？</li></ul></blockquote><ul><li><h5 id="权威定义"><a href="#权威定义" class="headerlink" title="权威定义"></a>权威定义</h5><ul><li><p><a href="https://www.cs.rochester.edu/~scott/pragmatics/" target="_blank" rel="noopener">《Programming Language Pragmatics》</a></p></li><li><p>原文内容</p><blockquote><p>In general, a value in a programming language is said to have ﬁrst-class status if it can be passed as a parameter, returned from a subroutine, or assigned into a variable.</p></blockquote></li></ul></li><li><h5 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h5><ul><li>函数可以赋值给变量</li><li>函数可以作为函数参数</li><li>函数可以作为返回值</li></ul></li><li><h5 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h5><ul><li><strong>函数为第一公民是函数式编程的基础</strong></li></ul></li></ul><h2 id="2-2-高阶函数"><a href="#2-2-高阶函数" class="headerlink" title="2.2~高阶函数"></a>2.2~高阶函数</h2><blockquote><p>问题：</p><ul><li>高阶函数的定义是什么？</li></ul></blockquote><ul><li><h5 id="高阶函数的定义"><a href="#高阶函数的定义" class="headerlink" title="高阶函数的定义"></a>高阶函数的定义</h5><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023021271742944" target="_blank" rel="noopener">参考廖老师的JavaScript教程</a></p></blockquote><ul><li>根据函数是一等公民的原理，函数可以作为函数的参数，那么我们将<strong>接收另一个函数作为参数的函数叫做高阶函数</strong></li></ul></li><li><h5 id="常用的高阶函数"><a href="#常用的高阶函数" class="headerlink" title="常用的高阶函数"></a>常用的高阶函数</h5><ul><li>map/reduce</li><li>filter</li><li>sort</li><li>Array</li><li>…</li></ul></li></ul><h2 id="2-3-闭包"><a href="#2-3-闭包" class="headerlink" title="2.3~闭包"></a>2.3~闭包</h2><blockquote><p>一种函数，一种现象</p></blockquote><ul><li><h5 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h5><ul><li>可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员</li></ul></li><li><h5 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h5><ul><li><p>变量生命的延长，规避死亡</p><blockquote><p>函数在执行的时候会放到一个执行栈上，当函数执行完毕 之后就会在执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员</p></blockquote></li></ul></li></ul><h1 id="3-函数式编程基础"><a href="#3-函数式编程基础" class="headerlink" title="3~函数式编程基础"></a>3~函数式编程基础</h1><blockquote><p>内容概括：</p><ul><li>纯函数</li><li>lodash</li><li>柯里化</li><li>管道</li><li>函数组合</li></ul></blockquote><h2 id="3-1-纯函数"><a href="#3-1-纯函数" class="headerlink" title="3.1~纯函数"></a>3.1~纯函数</h2><blockquote><p>问题:</p><ul><li>什么是纯函数？</li><li>纯函数在函数式编程中扮演着什么角色？</li></ul></blockquote><ul><li><h5 id="纯函数的定义"><a href="#纯函数的定义" class="headerlink" title="纯函数的定义"></a>纯函数的定义</h5><ul><li><strong>返回值只和参数有关的函数</strong>，与外部无关。无论外部发生什么样的变化，函数的返回值都不会改变。</li></ul></li><li><h5 id="纯函数的优点"><a href="#纯函数的优点" class="headerlink" title="纯函数的优点"></a>纯函数的优点</h5><ul><li><p>测试更加靠谱</p><ul><li>结果只和传入的参数有关</li></ul></li><li><p>优化并行处理</p></li><li><p>结果只和传入的参数有关无需 估计其他的共享内存数据</p></li><li><p>可缓存</p><blockquote><p>需借用loadsh中的memoize（函数记忆）方法</p></blockquote><ul><li>原理的依据就是，固定的参数对应唯一的输出结果</li></ul></li></ul></li><li><h5 id="纯函数也无法防御的不可抗因素-副作用"><a href="#纯函数也无法防御的不可抗因素-副作用" class="headerlink" title="纯函数也无法防御的不可抗因素(副作用)"></a>纯函数也无法防御的不可抗因素(副作用)</h5><blockquote><p>所有的<strong>外部交互</strong>都有可能产生副作用：</p><p>​        副作用也使得方法通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不问确定性，但是副作用不可能完全禁止，只能尽可能的控制它们在可控范围内发生。</p></blockquote><ul><li>配置文件</li><li>数据库</li><li>获取用户的输入输出</li><li>…</li></ul></li></ul><h2 id="3-2-Lodash"><a href="#3-2-Lodash" class="headerlink" title="3.2~Lodash"></a>3.2~Lodash</h2><blockquote><p><a href="https://www.lodashjs.com/" target="_blank" rel="noopener">Lodash</a>：一个一致性、模块化、高性能的 JavaScript 实用工具库。</p></blockquote><ul><li><h5 id="Lodash的用途"><a href="#Lodash的用途" class="headerlink" title="Lodash的用途"></a>Lodash的用途</h5><ul><li><p>功能库</p><ul><li>遍历 array、object 和 string</li><li>对值进行操作和检测</li><li>创建符合功能的函数—直指函数式编程</li></ul></li><li><p>简化函数式编程</p><blockquote><p>函数式编程指南：<a href="https://github.com/lodash/lodash/wiki/FP-Guide" target="_blank" rel="noopener">FP Guide</a></p></blockquote><ul><li>柯里化</li><li>函数组合</li><li>…</li></ul></li></ul></li></ul><h2 id="3-3-柯里化"><a href="#3-3-柯里化" class="headerlink" title="3.3~柯里化"></a>3.3~柯里化</h2><blockquote><p>问题：</p><ul><li><p>什么是柯里化？</p></li><li><p>柯里化的意义是什么？</p></li><li>柯里化带给了我们什么好处？</li></ul></blockquote><ul><li><h5 id="柯里化的定义"><a href="#柯里化的定义" class="headerlink" title="柯里化的定义"></a>柯里化的定义</h5><blockquote><p>一种技术</p></blockquote><ul><li>将可接收多个参数的函数，分解为可以接收单个参数并返回一个新的函数用来接收剩余参数的技术。<ul><li>参数的接收符合结合律，例如:1+2+3 = 1+(2+3) </li></ul></li><li>让函数变得更灵活，让函数的粒度更小</li></ul></li><li><h5 id="柯里化的用法"><a href="#柯里化的用法" class="headerlink" title="柯里化的用法"></a>柯里化的用法</h5><ul><li><p>柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些<strong>固定参数的新函数</strong>(一种对函数参数的缓存)</p></li><li><p>可以把多元函数转换成一元函数，可以<strong>组合使用函数</strong>产生强大的功能</p><ul><li>组合函数的依据就是柯里化</li></ul></li></ul></li><li><h5 id="Lodash对柯里化的支持"><a href="#Lodash对柯里化的支持" class="headerlink" title="Lodash对柯里化的支持"></a>Lodash对柯里化的支持</h5><ul><li><p>方法名：<strong>_.curry(func)</strong></p></li><li><p>功能：</p><ol><li>创建一个函数，该函数接收一个或多个func的参数，</li><li>如果func所需要的参数都被提供则执行func并返回执行的结果，否则继续返回该函数并等待接收剩余的参数</li></ol></li><li><p>使用示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入lodash模块</span></span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>)</span><br><span class="line"><span class="comment">// 定义一个简单的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对函数进行柯里化的处理</span></span><br><span class="line"><span class="keyword">const</span> curried = _.curry(getSum)</span><br><span class="line"><span class="comment">// 函数的参数可以分多次进行传递，直到传递完所有参数，函数才会执行</span></span><br><span class="line"><span class="built_in">console</span>.log(curried(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(curried(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(curried(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>))</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-4-函数组合"><a href="#3-4-函数组合" class="headerlink" title="3.4~函数组合"></a>3.4~函数组合</h2><blockquote><p>有分必有和</p><p>思想来源~Point Free</p><ul><li><p>一种编程风格，编程模式</p></li><li><p>内容：我们可以<strong>把数据处理的过程定义成与数据无关的合成运算</strong>，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。</p></li></ul></blockquote><ul><li><h5 id="函数组合的定义"><a href="#函数组合的定义" class="headerlink" title="函数组合的定义"></a>函数组合的定义</h5><blockquote><p>一种技术</p></blockquote><ul><li>如果一个函数要经过多个函数处理才能得到最终值，这个时候可以<strong>把中间过程的函数合并成一个函数</strong><ul><li>与柯里化搭配使用，可以将需要多个参数的函数方法串起来</li><li>符合结合律</li></ul></li></ul></li><li><h5 id="Lodash对函数组合的支持"><a href="#Lodash对函数组合的支持" class="headerlink" title="Lodash对函数组合的支持"></a>Lodash对函数组合的支持</h5><blockquote><p>需合理选择Lodash中的模块方法</p></blockquote><ul><li><p>方法</p><blockquote><p>Lodash提供了两种组合方法，唯一的不同的是合并的顺序不同</p></blockquote><ul><li>flow()</li><li>flowRight()</li></ul></li><li><p>lodash与lodash/fp的选择</p><blockquote><p>使用组合函数的时候，使用<strong>fp模块提供的方法</strong></p></blockquote><ul><li>lodash与lodash/fp的区别<ul><li>lodash的fp模块提供了使用的对函数式编程友好的方法<ul><li>lodash提供的方法需要单独对多参数函数进行处理</li></ul></li><li>提供了不可变auto-curried iteratee-first data-last的方法<ul><li><strong>函数优先，数据置后 </strong></li></ul></li></ul></li></ul></li><li><p>使用示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入模块</span></span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">'lodash/fp'</span>)</span><br><span class="line"><span class="comment">// -----------------------------调试</span></span><br><span class="line"><span class="comment">// 如果需要对代码进行调试，来判断出错的时候是哪一步出错，可以在那一步后面调用trace方法</span></span><br><span class="line"><span class="comment">// 定义一个函数，用来返回同输入值相同的输出值</span></span><br><span class="line"><span class="keyword">let</span> trace = _.curry(<span class="function">(<span class="params">tag, v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(tag, v)</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 例：trace('map之后输出的结果:')</span></span><br><span class="line"><span class="comment">// -------------------------------------</span></span><br><span class="line"><span class="comment">/* 需求：</span></span><br><span class="line"><span class="comment">    - 传入一个数组，里面包含多个字符串，</span></span><br><span class="line"><span class="comment">    - 每个字符串的首字母并转换为大写</span></span><br><span class="line"><span class="comment">    - 返回首字母组成的数组</span></span><br><span class="line"><span class="comment">    - 使用~连接成字符串 */</span></span><br><span class="line"><span class="comment">/* 使用技术：</span></span><br><span class="line"><span class="comment">    - 使用lodash中的flowRight组合一个函数，</span></span><br><span class="line"><span class="comment">    - 组合函数内的方法使用fp模块经过处理优化过的方法</span></span><br><span class="line"><span class="comment">        - map: 遍历</span></span><br><span class="line"><span class="comment">        - upperFirst: 首字母大写</span></span><br><span class="line"><span class="comment">        - first: 返回首字母</span></span><br><span class="line"><span class="comment">        - join: 使用连接符连接数组成字符串 */</span></span><br><span class="line"><span class="keyword">const</span> fn = fp.flowRight(fp.join(<span class="string">'~'</span>), fp.map(fp.first) ,fp.map(fp.upperFirst))</span><br><span class="line"><span class="built_in">console</span>.log(fn([<span class="string">'i'</span>, <span class="string">'love'</span>, <span class="string">'you'</span>])) <span class="comment">// 输出结果：I~L~Y</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="4-函子"><a href="#4-函子" class="headerlink" title="4~函子"></a>4~函子</h1><blockquote><p>狂轰滥炸，瞬间懵逼系列</p><p>问题：</p><ul><li>什么是函子？</li><li>它是干什么的？</li></ul></blockquote><ul><li><h5 id="函子的定义"><a href="#函子的定义" class="headerlink" title="函子的定义"></a>函子的定义</h5><ul><li>英文名称：Functor</li><li>函子的概念<ul><li>函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。</li><li>任何<strong>具有<code>map</code>方法的数据结构</strong>，都可以当作函子的实现。<ul><li>该方法将容器里面的每一个值，映射到另一个容器。</li></ul></li><li>是一种范畴，也就是说，是一个<strong>容器</strong>，<strong>包含了值和变形关系</strong>。<ul><li>包含了值，就是this.value</li><li>对外接口（map方法），各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形</li></ul></li><li>一般约定，函子有一个 of 方法，用来生成新的容器。</li></ul></li></ul></li><li><h5 id="函子的意义"><a href="#函子的意义" class="headerlink" title="函子的意义"></a>函子的意义</h5><ul><li>帮助我们更好的<strong>串行调用函数处理数据</strong>，类似于组合函数的功能</li><li>组合函数不具备的优点<ul><li>把副作用控制在可控范围内</li><li>异步处理</li><li>异步操作</li></ul></li></ul></li><li><h5 id="基本函子的代码实现"><a href="#基本函子的代码实现" class="headerlink" title="基本函子的代码实现"></a>基本函子的代码实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本的函子组成</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 约定的of方法，用于生成新的容器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义一个内部维护的值</span></span><br><span class="line">    <span class="keyword">constructor</span> (value) &#123;</span><br><span class="line">        <span class="keyword">this</span>._value = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对外提供的map方法，接收一个函数，通过of调用，用来改变内部的值， 并返回一个包含改变过的值的新的函子</span></span><br><span class="line">    map (fn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.of(fn(<span class="keyword">this</span>._value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="基本函子的使用"><a href="#基本函子的使用" class="headerlink" title="基本函子的使用"></a>基本函子的使用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 需求:</span></span><br><span class="line"><span class="comment">    - 传入一个字符串</span></span><br><span class="line"><span class="comment">    - 根据` `空格键将之分割成数组</span></span><br><span class="line"><span class="comment">    - 将数组中的每一段字符串的首字母转换为大写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 使用技术:</span></span><br><span class="line"><span class="comment">    - 基本的函子使用</span></span><br><span class="line"><span class="comment">    - lodash提供的方法</span></span><br><span class="line"><span class="comment">        - split: 分割字符串</span></span><br><span class="line"><span class="comment">        - map: 遍历</span></span><br><span class="line"><span class="comment">        - upperFirst: 首字母大写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 定义一个拥有以上需求的方法</span></span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">'lodash/fp'</span>)</span><br><span class="line"><span class="keyword">let</span> str_to_Arr = <span class="built_in">Function</span>.of(<span class="string">'i love you'</span>)</span><br><span class="line">                        .map(fp.split(<span class="string">' '</span>))</span><br><span class="line">                        .map(fp.map(fp.upperFirst))</span><br><span class="line"><span class="built_in">console</span>.log(str_to_Arr) <span class="comment">// 输出结果: Function &#123; _value: [ 'I', 'Love', 'You' ] &#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-1-MayBe函子"><a href="#4-1-MayBe函子" class="headerlink" title="4.1~MayBe函子"></a>4.1~MayBe函子</h2><blockquote><p>问题：</p><ul><li>已经有了函子，为什么还要多出一个MayBe函子？</li><li>MayBe函子解决的什么问题？</li></ul></blockquote><ul><li><h5 id="Functor基本函子存在的问题"><a href="#Functor基本函子存在的问题" class="headerlink" title="Functor基本函子存在的问题"></a>Functor基本函子存在的问题</h5><ul><li>传入空值会报错</li></ul></li><li><h5 id="MayBe函子的意义"><a href="#MayBe函子的意义" class="headerlink" title="MayBe函子的意义"></a>MayBe函子的意义</h5><ul><li>在Functor的基础上实现了<strong>空值的判断</strong></li></ul></li><li><h5 id="MayBe函子的代码实现"><a href="#MayBe函子的代码实现" class="headerlink" title="MayBe函子的代码实现"></a>MayBe函子的代码实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MayBe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MayBe(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span> (value) &#123;</span><br><span class="line">        <span class="keyword">this</span>._value = value</span><br><span class="line">    &#125;</span><br><span class="line">    map (fn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.isNothing() ? MayBe.of(<span class="literal">null</span>) : MayBe.of(fn(<span class="keyword">this</span>._value))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在Functor的基础上实现了空值的判断</span></span><br><span class="line">    isNothing () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._value === <span class="literal">null</span> || <span class="keyword">this</span>._value === <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="MayBe函子的使用"><a href="#MayBe函子的使用" class="headerlink" title="MayBe函子的使用"></a>MayBe函子的使用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 需求:</span></span><br><span class="line"><span class="comment">    - 传入一个字符串</span></span><br><span class="line"><span class="comment">    - 将字符串转换为驼峰写法</span></span><br><span class="line"><span class="comment">    - 传入一个空值null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 使用技术:</span></span><br><span class="line"><span class="comment">    - MayBe函子的使用</span></span><br><span class="line"><span class="comment">    - lodash提供的方法</span></span><br><span class="line"><span class="comment">        - camelCase: 将字符串转换为驼峰写法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">'lodash/fp'</span>)</span><br><span class="line"><span class="keyword">const</span> fn = MayBe.of(<span class="string">'maybe'</span>)</span><br><span class="line">                .map(fp.camelCase)</span><br><span class="line">                .map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">null</span>)</span><br><span class="line"><span class="built_in">console</span>.log(fn._value) <span class="comment">// 输出结果: null</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-2-Either函子"><a href="#4-2-Either函子" class="headerlink" title="4.2~Either函子"></a>4.2~Either函子</h2><blockquote><p>问题：</p><ul><li>Either函子解决了什么问题？</li></ul></blockquote><ul><li><h5 id="MayBe函子存在的问题"><a href="#MayBe函子存在的问题" class="headerlink" title="MayBe函子存在的问题"></a>MayBe函子存在的问题</h5><ul><li>MayBe函子解决了传入空值会报错的问题，返回了传入的空值，但是我们并不清楚到底是哪一步出了错误</li></ul></li><li><h5 id="Either函子的意义"><a href="#Either函子的意义" class="headerlink" title="Either函子的意义"></a>Either函子的意义</h5><ul><li>在MayBe函子的基础上，使我们可以精准的知道是哪一步出现了问题</li></ul></li><li><h5 id="Either函子的代码实现"><a href="#Either函子的代码实现" class="headerlink" title="Either函子的代码实现"></a>Either函子的代码实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置左右两个函子，再判断之后执行需要执行的函子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Left</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Left(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span> (value) &#123;</span><br><span class="line">        <span class="keyword">this</span>._value = value</span><br><span class="line">    &#125;</span><br><span class="line">    map (fn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Right</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Right(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span> (value) &#123;</span><br><span class="line">        <span class="keyword">this</span>._value = value</span><br><span class="line">    &#125;</span><br><span class="line">    map (fn) &#123;</span><br><span class="line">        <span class="keyword">return</span> Right.of(fn(<span class="keyword">this</span>._value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="Either函子的使用"><a href="#Either函子的使用" class="headerlink" title="Either函子的使用"></a>Either函子的使用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Either</span> (<span class="params">parameter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 利用JSON.parse第一个参数的限制，来空值左右的调用</span></span><br><span class="line">        <span class="keyword">return</span> Right.of(<span class="built_in">JSON</span>.parse(parameter))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> Left.of(&#123; <span class="attr">error</span>: e.message &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn = Either() <span class="comment">// 传入空值</span></span><br><span class="line">                .map(<span class="function"><span class="params">x</span> =&gt;</span> x)</span><br><span class="line"><span class="built_in">console</span>.log(fn) <span class="comment">// 输出内容: Left &#123; _value: &#123; error: 'Unexpected token u in JSON at position 0' &#125; &#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-3-Task函子"><a href="#4-3-Task函子" class="headerlink" title="4.3~Task函子"></a>4.3~Task函子</h2><blockquote><p>一个用法极为特殊的函子,由<strong>Folktale提供</strong></p><p>问题：</p><ul><li>Task函子解决了什么问题？</li></ul></blockquote><ul><li><h5 id="Task函子的意义"><a href="#Task函子的意义" class="headerlink" title="Task函子的意义"></a>Task函子的意义</h5><ul><li><strong>处理异步任务</strong></li></ul></li><li><h5 id="Task的特殊性"><a href="#Task的特殊性" class="headerlink" title="Task的特殊性"></a>Task的特殊性</h5><ul><li>本身就是一个函数，参数需要接收一个函数</li><li>固定的参数<ul><li>resolver</li></ul></li><li>固定的方法<ul><li>reject</li><li>resolve</li></ul></li></ul></li><li><h5 id="Task的使用"><a href="#Task的使用" class="headerlink" title="Task的使用"></a>Task的使用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> task函子，处理异步任务----------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    folktale 2.3.2版本演示</span></span><br><span class="line"><span class="comment">    需求：</span></span><br><span class="line"><span class="comment">        - 获取配置文件</span></span><br><span class="line"><span class="comment">        - 拆分配置文件</span></span><br><span class="line"><span class="comment">        - 获取包含自定字段的配置项</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*  使用技术：</span></span><br><span class="line"><span class="comment">        - fs文件请求</span></span><br><span class="line"><span class="comment">        - task的使用方法</span></span><br><span class="line"><span class="comment">        - lodash提供的方法</span></span><br><span class="line"><span class="comment">            - split: 切割</span></span><br><span class="line"><span class="comment">            - find: 遍历 collection（集合）元素，返回 predicate（断言函数）第一个返回真值的第一个元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; task &#125; = <span class="built_in">require</span>(<span class="string">'folktale/concurrency/task'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; split, find &#125; = <span class="built_in">require</span>(<span class="string">'lodash/fp'</span>)</span><br><span class="line"><span class="comment">// 定义一个读文件的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// task函子的使用</span></span><br><span class="line">    <span class="keyword">return</span> task(<span class="function"><span class="params">resolver</span> =&gt;</span> &#123;</span><br><span class="line">        fs.readFile(filename, <span class="string">'utf-8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) resolver.reject(err)</span><br><span class="line">            resolver.resolve(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用异步任务</span></span><br><span class="line">readFile(<span class="string">'package.json'</span>)</span><br><span class="line">    .map(split(<span class="string">'\n'</span>))</span><br><span class="line">    .map(find(<span class="function"><span class="params">x</span> =&gt;</span> x.includes(<span class="string">'version'</span>)))</span><br><span class="line">    .run()</span><br><span class="line">    .listen(&#123;</span><br><span class="line">        onRejected: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err)</span><br><span class="line">        &#125;,</span><br><span class="line">        onResolved: <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(value) <span class="comment">// 输出结果："version": "1.0.0"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-4-IO函子"><a href="#4-4-IO函子" class="headerlink" title="4.4~IO函子"></a>4.4~IO函子</h2><blockquote><p>问题：</p><ul><li>IO函子解决了什么问题？</li></ul></blockquote><ul><li><h5 id="IO函子的意义"><a href="#IO函子的意义" class="headerlink" title="IO函子的意义"></a>IO函子的意义</h5><blockquote><p>控制函数的每一节的输入与输出，多个开关的水龙头</p><p>每一节只有调用才会继续执行</p></blockquote><ul><li>IO函子中的_value是一个函数，这里是把函数作为值来处理</li><li>IO函子可以把不纯的动作存储到_value中，包装当前的操作使其变纯，延迟执行这个不纯的操作(惰性执行)到调用的时候</li><li>把不纯的操作交给调用者来执行</li></ul></li><li><h5 id="IO函子的的代码实现"><a href="#IO函子的的代码实现" class="headerlink" title="IO函子的的代码实现"></a>IO函子的的代码实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">'lodash/fp'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span> (fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>._value = fn</span><br><span class="line">    &#125;</span><br><span class="line">    map (fn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IO(fp.flowRight(fn, <span class="keyword">this</span>._value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="IO函子的使用"><a href="#IO函子的使用" class="headerlink" title="IO函子的使用"></a>IO函子的使用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = IO.of(process)</span><br><span class="line">.map(<span class="function"><span class="params">p</span> =&gt;</span> p.execPath)._value()</span><br><span class="line"><span class="built_in">console</span>.log(fn) <span class="comment">// 输出结果：C:\dev\nodejs\node.exe</span></span><br><span class="line"><span class="comment">// 无论过程如何，执行操作肯定是纯的，在调用的时候才会体现</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-5-Monad函子"><a href="#4-5-Monad函子" class="headerlink" title="4.5~Monad函子"></a>4.5~Monad函子</h2><blockquote><p>弥补以下IO函子的不足</p></blockquote><ul><li><h5 id="Monad函子的意义"><a href="#Monad函子的意义" class="headerlink" title="Monad函子的意义"></a>Monad函子的意义</h5><blockquote><p>多个水龙头拥有的统一的开关</p></blockquote><ul><li>再IO函数的基础上，使其可以通过一次调用，输出最终内容</li><li>比IO函数多出来的两个方法<ul><li>join()<ul><li>一步到位输出结果</li></ul></li><li>flatMap()<ul><li>组合map与join方法</li><li>将可以不纯的操作，提前通过调用来执行，避免最后的多次调用</li></ul></li></ul></li></ul></li><li><h5 id="Monad函子的代码实现"><a href="#Monad函子的代码实现" class="headerlink" title="Monad函子的代码实现"></a>Monad函子的代码实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monad</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Monad(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span> (fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>._value = fn</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于组合函数与函子内部的_value</span></span><br><span class="line">    map (fn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Monad(fp.flowRight(fn, <span class="keyword">this</span>._value))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 加上join方法后,就符合了monad的要求</span></span><br><span class="line">    <span class="comment">// 将函子调用变扁，拍平的核心所在</span></span><br><span class="line">    join () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._value()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 组合map与join方法</span></span><br><span class="line">    flatMap (fn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.map(fn).join()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="Monad函子的使用"><a href="#Monad函子的使用" class="headerlink" title="Monad函子的使用"></a>Monad函子的使用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">'lodash/fp'</span>)</span><br><span class="line"><span class="comment">// 定义一个读取文件操作</span></span><br><span class="line"><span class="keyword">let</span> readFile_IO_Monad = <span class="function"><span class="keyword">function</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO_Monad(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fs.readFileSync(filename, <span class="string">'utf-8'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个打印操作</span></span><br><span class="line"><span class="keyword">let</span> print_IO_Monad = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO_Monad(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = readFile_IO_Monad(<span class="string">'package.json'</span>)</span><br><span class="line">            .map(fp.toUpper)</span><br><span class="line">            .flatMap(print_IO_Monad)</span><br><span class="line">            .join()</span><br><span class="line"><span class="built_in">console</span>.log(fn)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 拉钩大前端学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript语言学习笔记</title>
      <link href="/2020/05/23/TypeScript%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/23/TypeScript%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="课程概括"><a href="#课程概括" class="headerlink" title="课程概括"></a>课程概括</h1><blockquote><p>TypeScript解决的痛点：</p><p>​    解决了JavaScript类型系统的问题</p></blockquote><ul><li>内容概括<ul><li>强类型与弱类型</li><li>静态类型与动态类型</li><li>JavaScript自有类型系统的问题</li><li>Flow静态类型检查方案</li><li>TypeScriptt语言规范与基本应用</li></ul></li></ul><h1 id="1·类型的问题"><a href="#1·类型的问题" class="headerlink" title="1·类型的问题"></a>1·类型的问题</h1><blockquote><p>编程语言按类型区分：</p><p>​    强类型与弱类型（类型安全）</p><p>​    静态类型与动态类型（类型检查）</p></blockquote><h2 id="1-1·强类型与弱类型"><a href="#1-1·强类型与弱类型" class="headerlink" title="1.1·强类型与弱类型"></a>1.1·强类型与弱类型</h2><blockquote><p>从类型安全角度来区分：</p><p>​    强类型与弱类型</p><p>对于类型的限制的强弱问题</p><p>由于这种强弱类型之分根本不是某个权威机构的定义，因此强弱类型的界定方式，基本集中于类型约束问题</p></blockquote><ul><li><p>强类型 </p><ul><li>在语言层面限制函数的实参类型必须与形参类型相同</li><li>强类型语言中不允许任意的隐式类型转换</li><li>优势<ul><li>错误更早暴漏，在编码阶段即可体现</li><li>代码更加智能，编码更加准确</li><li>重构更牢靠</li><li>减少不必要的类型判断</li></ul></li></ul></li><li><p>弱类型</p><ul><li><p>弱类型在语言层面不会限制实参的类型</p></li><li><p>弱类型语言则允许任意的数据隐式类型转换</p></li><li><p>实际产生的问题</p><ul><li><p>异常只有在运行后才会体现</p></li><li><p>类型不明确，函数功能就不确定</p></li><li><p>对象索引器的错误用法</p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    弱类型的问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">obj.foo()</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   obj.foo() </span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">100</span>, <span class="string">'100'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">obj[<span class="literal">true</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">'true'</span>])</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><blockquote><p>由于弱类型照成的问题虽然可以通过约定来解决，但是</p><p>​    君子约定有隐患，强制要求有保障</p></blockquote><h2 id="1-2·静态类型与动态类型"><a href="#1-2·静态类型与动态类型" class="headerlink" title="1.2·静态类型与动态类型"></a>1.2·静态类型与动态类型</h2><blockquote><p>从类型检查角度来区分</p><p>​    静态类型与动态类型 </p></blockquote><ul><li>静态类型<ul><li>一个变量在声明时就明确了类型，且不允许再次修改</li></ul></li><li>动态类型<ul><li>在运行阶段才能明确一个数据的类型，且变量的类型可以随时改变</li><li>动态类型的语言中，变量没有类型，而变量中存放的值是有类型的</li></ul></li></ul><h2 id="1-3·JavaScript类型系统特征"><a href="#1-3·JavaScript类型系统特征" class="headerlink" title="1.3·JavaScript类型系统特征-"></a>1.3·JavaScript类型系统特征-</h2><blockquote><p>弱类型 且 动态类型</p></blockquote><ul><li>优点：<ul><li>高自由度，高灵活度</li></ul></li><li>缺点<ul><li>缺失了类型系统的可靠性</li></ul></li></ul><blockquote><p>为什么JavaScript不是一门强类型，静态类型的语言:</p><ul><li>早期设计的应用场景简单</li><li>脚本语言，没有编译环节，无法进行类型检查</li></ul></blockquote><h1 id="2·Flow"><a href="#2·Flow" class="headerlink" title="2·Flow"></a>2·Flow</h1><blockquote><p>JavaScript的类型检查器</p><p>使用参考：<a href="https://www.jianshu.com/p/7716dc8b2206" target="_blank" rel="noopener">简书文字，flow的使用</a></p></blockquote><ul><li>安装：<code>yarn add flow-bin --dev</code></li></ul><h2 id="2-1·格式示例"><a href="#2-1·格式示例" class="headerlink" title="2.1·格式示例"></a>2.1·格式示例</h2><blockquote><p>演示</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    flow的体验</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过注释开启flow校验：</span></span><br><span class="line"><span class="comment">    0.安装：yarn add flow-bin --dev</span></span><br><span class="line"><span class="comment">    1.在js开头声明`@flow`,通过`: number`添加类型注释</span></span><br><span class="line"><span class="comment">    2.关闭编辑器自带的校验 javascriprt validate:false</span></span><br><span class="line"><span class="comment">    3.初始化flow配置文件：yarn flow init</span></span><br><span class="line"><span class="comment">    4.运行flow：yarn flow</span></span><br><span class="line"><span class="comment">    5.停止flow：yarn flow stop</span></span><br><span class="line"><span class="comment">    6.清除注释，@balel/preset-flow 或者 yarn add flow-remove-types =&gt; yarn flow-remove-types . -d dist</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    安装插件，保存即可找到错误：flow language support</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能 */</span></span><br><span class="line"><span class="comment">// -------------------------------</span></span><br><span class="line"><span class="comment">// -----------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    类型推断</span></span><br><span class="line"><span class="comment">        自动推断变量或者参数的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * n </span><br><span class="line">&#125;</span><br><span class="line">square(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    flow支持的原始类型</span></span><br><span class="line"><span class="comment">        string number boolean null undefined symbol</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> a: string = <span class="string">'abel'</span></span><br><span class="line"><span class="keyword">const</span> b: number = <span class="number">123456</span> <span class="comment">// NaN // Infinity</span></span><br><span class="line"><span class="keyword">const</span> c: boolean = <span class="literal">false</span> <span class="comment">// trun</span></span><br><span class="line"><span class="keyword">const</span> d: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> e: <span class="keyword">void</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">const</span> g: symbol = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="comment">// ----------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    数组类型限制</span></span><br><span class="line"><span class="comment">        Array</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr1: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// 限制数组，并且限制数组成员类型</span></span><br><span class="line"><span class="keyword">const</span> arr2: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元组，定制数组组成,定制只能有几个成员组成，并声明每一个成员的类型</span></span><br><span class="line"><span class="keyword">const</span> arr3: [string, number] = [<span class="string">'foo'</span>, <span class="number">100</span>]</span><br><span class="line"><span class="comment">// --------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    对象类型限制</span></span><br><span class="line"><span class="comment">        Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1: &#123; <span class="attr">foo</span>: string, <span class="attr">bar</span>: number &#125; = &#123; <span class="attr">foo</span>: <span class="string">'string'</span>, <span class="attr">bar</span>: <span class="number">100</span> &#125; <span class="comment">// 限制对象属性个数，并且限制对象的成员名称以及类型</span></span><br><span class="line"><span class="keyword">const</span> obj2: &#123; foo?: string, <span class="attr">bar</span>: number &#125; = &#123; <span class="attr">bar</span>: <span class="number">100</span> &#125; <span class="comment">// ?修饰的属性名表示可以有可以没有</span></span><br><span class="line"><span class="keyword">const</span> obj3: &#123; [string]: string &#125; = &#123;&#125; <span class="comment">// 不限制属性的个数，但是限制属性的类型以及属性值的类型</span></span><br><span class="line">obj3.key1 = <span class="string">'value1'</span></span><br><span class="line">obj3.key2 = <span class="string">'value2'</span></span><br><span class="line"><span class="comment">// --------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    函数类型限制</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span> (<span class="params">a: number, b: number</span>) </span>&#123; <span class="comment">// 用于形参</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">foo1(<span class="number">100</span>, <span class="number">100</span>) <span class="comment">// 实参只能是形参声明的类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span> (<span class="params"></span>):<span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> <span class="comment">// 用于函数，函数的返回值只能是声明的类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo3</span> (<span class="params">callback: (string, number</span>) =&gt; <span class="title">void</span>) </span>&#123; <span class="comment">// 用于回调函数以及回调函数的返回值</span></span><br><span class="line">    callback(<span class="string">'string'</span>, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo3(<span class="function"><span class="keyword">function</span> (<span class="params">str, n</span>) </span>&#123;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// -------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    特殊类型</span></span><br><span class="line"><span class="comment">        字面量 自定义类型限制   `|`的使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> str1: <span class="string">'foo'</span> = <span class="string">'foo'</span> <span class="comment">// 限制字符串只能为固定内容   </span></span><br><span class="line"><span class="keyword">const</span> type: <span class="string">'success'</span> | <span class="string">'waring'</span> | <span class="string">'danger'</span> = <span class="string">'success'</span></span><br><span class="line"></span><br><span class="line">type StringOrNumber = string | number <span class="comment">// 自定义个限制类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str2: StringOrNumber = <span class="string">'string'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gender: ?number = <span class="literal">null</span> <span class="comment">// ?设置可以为控或者undefind === const gender: number | null | void</span></span><br><span class="line"><span class="comment">// ------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Mixed 与 Any</span></span><br><span class="line"><span class="comment">        mixed === any === 任意类型</span></span><br><span class="line"><span class="comment">        mixed 强类型 更为安全，只有通过判断才能对参数进一步的处理</span></span><br><span class="line"><span class="comment">        any 弱类型 不推荐使用，主要用来兼容以前的老代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mixed </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passMixed</span> (<span class="params">value: mixed</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">'string'</span>)</span><br><span class="line">    value.substr(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">'number'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(value * value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// passMixed('string')</span></span><br><span class="line">passMixed(<span class="number">100</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passAny</span> (<span class="params">value: any</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// value.substr(1)</span></span><br><span class="line">    <span class="built_in">console</span>.log(value * value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// passAny('string')</span></span><br><span class="line">passAny(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    运行环境 API 对于运行环境的限制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element: HTMLElement | <span class="literal">null</span> = <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    flow类型的总结</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    学习的目的，主要用于在今后学习框架源码的时候，能够明白使用了flow的部分的意义</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="3·TypeScript"><a href="#3·TypeScript" class="headerlink" title="3·TypeScript"></a>3·TypeScript</h1><blockquote><p>JavaScript的超集(superset)，渐进式的提升</p><p>TypeScript—-前端领域的第二语言</p></blockquote><p><img src="https://pics.images.ac.cn/image/5ec6aa935f786.html" alt="TypeScript"></p><ul><li>任何环境下的JavaScript都支持</li><li>比起flow，功能更为强大，生态更加健全，更完善</li></ul><h2 id="3-1·TypeScript的初始"><a href="#3-1·TypeScript的初始" class="headerlink" title="3.1·TypeScript的初始"></a>3.1·TypeScript的初始</h2><blockquote><p>TypeScipt的安装与配置</p></blockquote><ul><li>安装：<code>yarn add typescript --dev</code></li><li>转换单个文件：<ul><li>全部转换为使用es3的标准，完全兼容之前的老代码</li><li>运行：<code>yarn tsc ts文件名</code></li></ul></li><li>转换整个项目或工程<ul><li>初始化配置文件：<code>yarn tsc --init</code></li><li>根据需求更改tsc配置文件</li><li>运行：<code>yarn tsc</code><ul><li>中文报错：<code>yarn tsc --locale zh-CN</code></li><li>vscode报错的中文设置setting=&gt;typescript local=ch-cn</li></ul></li></ul></li></ul><h2 id="3-2·基本数据类型"><a href="#3-2·基本数据类型" class="headerlink" title="3.2·基本数据类型"></a>3.2·基本数据类型</h2><blockquote><p>基本类型，在ts配置文件中，只有设置非严格模式，才能默认允许为空</p></blockquote><ul><li><p>基本类型包括：</p><ul><li>string</li><li>number</li><li>boolean</li><li>void</li><li>null</li><li>underfined</li><li>symbol</li><li>any<ul><li>弱类型，动态类型，存在安全问题</li></ul></li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    如何让ts报错显示中文</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行指令：`yarn tsc --locale zh-CN`</span></span><br><span class="line"><span class="comment">// ------------------------------------------------------</span></span><br><span class="line"><span class="keyword">const</span> a: string = <span class="string">'我是一个字符串'</span></span><br><span class="line"><span class="keyword">const</span> b: number = <span class="number">123456</span> <span class="comment">// NaN // Infinity</span></span><br><span class="line"><span class="keyword">const</span> c: boolean = <span class="literal">true</span></span><br><span class="line"><span class="comment">// const d: boolean = null // 严格模式下不能null</span></span><br><span class="line"><span class="keyword">const</span> e: <span class="keyword">void</span> = <span class="literal">undefined</span> <span class="comment">// void只能为undefined不能是null</span></span><br><span class="line"><span class="keyword">const</span> f: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> g: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">const</span> h: symbol = <span class="built_in">Symbol</span>()</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-3·引用数据类型"><a href="#3-3·引用数据类型" class="headerlink" title="3.3·引用数据类型"></a>3.3·引用数据类型</h2><blockquote><p>对于引用型数据类型的约束</p></blockquote><ul><li><p>Array</p><ul><li><p>限制变量为数组</p><ul><li><p>关键词：Array || []</p></li><li><p>限制数组成员：<number> || number</number></p><blockquote><p>以number为例</p></blockquote></li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Array类型的限制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> arr1: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// 限制数组类型，且限制数组中的成员类型必须为数字</span></span><br><span class="line"><span class="keyword">const</span> arr2: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">...args: number[]</span>) </span>&#123; <span class="comment">// 限制传进来的参数必须都是数字</span></span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">prev, current</span>) =&gt;</span> prev + current, <span class="number">0</span>) <span class="comment">// 计算累加和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Object</p><ul><li><p>限制变量为对象</p></li><li><p>关键词：Object || {}</p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Object类型的限制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> foo1: object = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 限制函数类型</span></span><br><span class="line"><span class="keyword">const</span> obj1: &#123; <span class="attr">foo</span>: number, <span class="attr">bar</span>: string&#125; = &#123; <span class="attr">foo</span>: <span class="number">123</span>, <span class="attr">bar</span>: <span class="string">'string'</span> &#125; <span class="comment">// 限制对象属性个数，属性的名字以及属性值的类型、</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>function</p><blockquote><p>对于参数以及返回值的约束</p></blockquote><ul><li><p>限制参数类型</p></li><li><p>限制返回值类型</p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    函数的类型约束 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span> (<span class="params">a: number, b: number = <span class="number">10</span>, c?: number, ...rest: number[]</span>): <span class="title">string</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// 设置参数类型，参数默认值，可选参数，剩余参数，以及返回值类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'这里只能返回字符串了'</span></span><br><span class="line">&#125;</span><br><span class="line">foo2(<span class="number">100</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">56</span>, <span class="number">56</span>)</span><br><span class="line"><span class="comment">// 函数表达式,定义回调函数类型</span></span><br><span class="line"><span class="keyword">const</span> foo3: <span class="function">(<span class="params">a: number, b: number</span>) =&gt;</span> string = <span class="function"><span class="keyword">function</span> (<span class="params">a: number, b: number</span>):<span class="title">string</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'这里只能返回字符串了'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-4·类型系统新增数据结构"><a href="#3-4·类型系统新增数据结构" class="headerlink" title="3.4·类型系统新增数据结构"></a>3.4·类型系统新增数据结构</h2><blockquote><p>数组对应的元组，限定值内容的枚举，参数的接口</p></blockquote><ul><li><p>元组</p><ul><li><p>说明：用来明确元素数量，以及各个元素的类型</p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    元组类型</span></span><br><span class="line"><span class="comment">        数据结构</span></span><br><span class="line"><span class="comment">        明确元素数量，以及各个元素类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tuple: [number, string] = [<span class="number">18</span>, <span class="string">'abel'</span>]</span><br><span class="line"><span class="comment">// 妙用：</span></span><br><span class="line"><span class="built_in">Object</span>.entries(&#123; <span class="comment">// 通过entries获取对象的属性以键值对的模式，输出的结果就是一个元组，因为限制了成员数量</span></span><br><span class="line">    foo: <span class="number">123</span>,</span><br><span class="line">    bar: <span class="number">456</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>枚举</p><ul><li><p>说明：用来限定内容选择，并声明选项的意义</p></li><li><p>关键词：enum</p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    枚举类型</span></span><br><span class="line"><span class="comment">        数据结构</span></span><br><span class="line"><span class="comment">        限制选项，并声明选项的意义</span></span><br><span class="line"><span class="comment">        关键词: enum</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 不加const编译后，成为一个双向的键值对对象，加const之后，会出现代码入侵的效果，引用枚举的地方，会直接替换成枚举的值</span></span><br><span class="line"><span class="keyword">const</span> enum PostStatus &#123; <span class="comment">// 特有的枚举类型，与对象的不同是，键值对：换成了等号</span></span><br><span class="line">    Draft = <span class="number">0</span>,</span><br><span class="line">    Unpublished = <span class="number">1</span>,</span><br><span class="line">    Published = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> post = &#123;</span><br><span class="line">    title: <span class="string">'hello typescript'</span>,</span><br><span class="line">    content: <span class="string">'typescript is a typed superset of javascript'</span>,</span><br><span class="line">    status: PostStatus.Draft <span class="comment">// 限制值只能为枚举类型中的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Interfaces接口</p><ul><li><p>说明：用来单独定义函数中，参数的内容</p></li><li><p>关键词：Interfaces</p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Interfaces接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">interface Post &#123; <span class="comment">// 定义接口</span></span><br><span class="line">    title: string <span class="comment">// 定义接口成员类型</span></span><br><span class="line">    readonly summary: string <span class="comment">// 只读成员</span></span><br><span class="line">    content: string</span><br><span class="line">    subtitle?: string <span class="comment">// 可选成员 // string | undefined</span></span><br><span class="line">&#125;</span><br><span class="line">interface Cache &#123;</span><br><span class="line">    [key: string]: string | number<span class="comment">// 动态接口成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPost</span> (<span class="params">post: Post</span>) </span>&#123; <span class="comment">// 将参数类型指定为接口名称</span></span><br><span class="line">    <span class="built_in">console</span>.log(post.title)</span><br><span class="line">    <span class="built_in">console</span>.log(post.content)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cache: Cache = &#123;&#125;</span><br><span class="line">cache.name = <span class="string">'abel'</span></span><br><span class="line">cache.age = <span class="number">12</span></span><br><span class="line">printPost(&#123; <span class="comment">// 必须符合接口要求，实参才能正确传递</span></span><br><span class="line">    title: <span class="string">'hello typescript'</span>,</span><br><span class="line">    summary: <span class="string">'aa'</span>,</span><br><span class="line">    content: <span class="string">'A javascript superset'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-5·类型的推断与断言"><a href="#3-5·类型的推断与断言" class="headerlink" title="3.5·类型的推断与断言"></a>3.5·类型的推断与断言</h2><blockquote><p>隐式类型推断与不明确类型的断言</p></blockquote><ul><li><p>推断</p><ul><li><p>说明：ts会自动为每一个未明确的类型，根据上下文的使用与赋值设立默认的类型</p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    隐式类型推断</span></span><br><span class="line"><span class="comment">        建议为每一个变量添加明确的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line"><span class="comment">// age = 'eight' // 隐式推断age为number，因此无法再次赋值为字符串</span></span><br><span class="line"><span class="keyword">let</span> any1 <span class="comment">// 当隐式类型无法推断一个类型的时候，会将之类型判断为any</span></span><br><span class="line">any1 = <span class="number">123</span></span><br><span class="line">any1 = <span class="string">'123'</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>断言</p><ul><li><p>说明：系统无法自动判断的类型，需要断言是那种类型才可以进行下一步的使用</p></li><li><p>注意：断言不等于类型转换</p></li><li><p>关键词：as</p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    类型断言</span></span><br><span class="line"><span class="comment">        关键词: as、</span></span><br><span class="line"><span class="comment">        不等于类型转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> res = nums.find(<span class="function"><span class="params">i</span> =&gt;</span> i &gt; <span class="number">0</span>) <span class="comment">// res类型不明确，无法直接进行数学运算</span></span><br><span class="line"><span class="keyword">const</span> square = (res <span class="keyword">as</span> number) * (res <span class="keyword">as</span> number) <span class="comment">// 类型断言，确定的说明不确定的类型为某个类型，以便其进行下一步的操作</span></span><br><span class="line"><span class="keyword">const</span> num1 = <span class="xml"><span class="tag">&lt;<span class="name">number</span>&gt;</span>res // 不推荐使用，因为在jsx中，会和标签产生冲突</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-6·类的修饰符"><a href="#3-6·类的修饰符" class="headerlink" title="3.6·类的修饰符"></a>3.6·类的修饰符</h2><blockquote><p>class：</p><p>​    用于描述一类事物的抽象特征</p><p>​    是ts对class的增强</p><p>​    访问修饰符&amp;抽象类</p></blockquote><ul><li><p>访问修饰符</p><ul><li>说明: ts中新增的三种访问修饰符，用来控制属性的可访问限制级别<ul><li>public: 公有属性，字类可以继承并通过实例化对象属性访问</li><li>protected: 保护属性，字类可以继承，但是无法通过实例化对象属性来访问</li><li>private: 只能在class内部使用，无法继承，也无法通过实例化对象属性访问</li></ul></li></ul></li><li><p>另外在修饰符后面还可以添加只读，限制属性不可更改</p></li><li><p>readonly: 只读属性</p></li><li><p>格式示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* </span><br><span class="line">    类的定义：</span><br><span class="line">        描述一类事物的抽象特征</span><br><span class="line">    ts对于class的增强</span><br><span class="line">        访问修饰符</span><br><span class="line">        抽象类的概念</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;&#x2F; ------------------------------------------------------</span><br><span class="line">&#x2F;* </span><br><span class="line">    三个访问修饰符，用来控制属性的可访问限制级别</span><br><span class="line">        public: 公有属性，字类可以继承并通过实例化对象属性访问</span><br><span class="line">        protected: 保护属性，字类可以继承，但是无法通过实例化对象属性来访问</span><br><span class="line">        private: 只能在class内部使用，无法继承，也无法通过实例化对象属性访问</span><br><span class="line"></span><br><span class="line">        readonly: 只读属性</span><br><span class="line">*&#x2F;</span><br><span class="line">class Person &#123;</span><br><span class="line">    &#x2F;&#x2F; 类是属性必须拥有值，要不再这里赋值初始值，要不在构造函数中，赋值</span><br><span class="line">    name: string &#x3D; &#39;init name&#39;</span><br><span class="line">    private age: number &#x2F;&#x2F; 定义私有属性</span><br><span class="line">    public className: string &#x3D; &#39;1班&#39; &#x2F;&#x2F; 公有属性</span><br><span class="line">    protected gender: boolean &#x2F;&#x2F; 添加保护属性 </span><br><span class="line">    public readonly grade: number &#x3D; 2016 &#x2F;&#x2F; 只读属性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    constructor (name: string, age: number) &#123; &#x2F;&#x2F; 限定属性值的类型</span><br><span class="line">        this.name &#x3D; name</span><br><span class="line">        this.age &#x3D; age</span><br><span class="line">        this.gender &#x3D; true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayHi (msg: string): void &#123; &#x2F;&#x2F; 限定参数以及返回类型</span><br><span class="line">        console.log(&#96;i am $&#123;this.name&#125;,$&#123;this.age&#125;&#96;)</span><br><span class="line">        console.log(msg)</span><br><span class="line">        console.log(this.gender)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person &#123;</span><br><span class="line">    &#x2F;&#x2F; es6固有的私有修饰符,外部无法访问构造函数，只能通过class的公开方法来实例化</span><br><span class="line">    private constructor (name: string, age: number) &#123;</span><br><span class="line">        super(name, age)</span><br><span class="line">        console.log(this.gender) &#x2F;&#x2F; 私有属性字类无法继承，但是受保护的属性可以被字类继承</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 通过static公开的构造函数方法 来实例化对象</span><br><span class="line">    static create (name: string, age: number) &#123;</span><br><span class="line">        return new Student(name, age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const abel &#x3D; new Person(&#39;abel&#39;, 18)</span><br><span class="line"></span><br><span class="line">console.log(abel.className) &#x2F;&#x2F; 公有属性可以在实例化对象中直接访问</span><br><span class="line">&#x2F;&#x2F; console.log(abel.gender, abel.age) &#x2F;&#x2F; 私有属性和受保护的属性都无法访问</span><br><span class="line"></span><br><span class="line">const jack &#x3D; Student.create(&#39;jack&#39;, 18)</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-7·类的接口与抽象类"><a href="#3-7·类的接口与抽象类" class="headerlink" title="3.7·类的接口与抽象类"></a>3.7·类的接口与抽象类</h2><blockquote><p>类的接口与抽象类，功能相近，但不尽相同，都用来约束引用它们的对象</p></blockquote><ul><li><p>类的接口</p><ul><li><p>关键词：interface</p></li><li><p>说明：约束多个类中，必须拥有某种方法，接口中不声明方法体，只声明方法名与类型</p></li><li><p>格式示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* </span><br><span class="line">    接口：</span><br><span class="line">        关键词：interface</span><br><span class="line">    什么使用需要接口？</span><br><span class="line">        两个类中，拥有相同的方法，但是方法的实现过程不一样，可以用来约束必须有此方法</span><br><span class="line">        推荐一个接口，只去约束一个方法，不需要方法体</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">interface Eat &#123;</span><br><span class="line">    eat (food: string): void &#x2F;&#x2F; 在接口中限制行为的参数类型，返回值类型</span><br><span class="line">&#125;</span><br><span class="line">interface Run &#123;</span><br><span class="line">    run (distance: number): void &#x2F;&#x2F; 推荐一个接口只限制一个行为</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person implements Eat, Run &#123; &#x2F;&#x2F; 接口关键词后面可以接多个接口，可以用逗号隔开即可</span><br><span class="line">    eat (food: string): void &#123;</span><br><span class="line">        console.log(&#96;优雅的吃$&#123;food&#125;&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">    run (distance: number): void &#123;</span><br><span class="line">        console.log(&#96;直立行走$&#123;distance&#125;&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Animal implements Eat, Run &#123;</span><br><span class="line">    eat (food: string): void &#123;</span><br><span class="line">        console.log(&#96;呼噜呼噜的吃$&#123;food&#125;&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">    run (distance: number): void &#123;</span><br><span class="line">        console.log(&#96;爬行$&#123;distance&#125;&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>抽象类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们都是人，人就是一个抽象的概念，人也属于动物，动物相对于人来说，又是一个抽象类</span><br></pre></td></tr></table></figure><ul><li><p>关键词：abstract</p></li><li><p>说明：用来概括类的父级，更高级的分类，可以设置有方法体的方法，也可以只设置方法名与参数类型，返回值类型</p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    抽象类：</span></span><br><span class="line"><span class="comment">        关键词：abstract</span></span><br><span class="line"><span class="comment">    什么时候需要使用抽象类:</span></span><br><span class="line"><span class="comment">        用来抽象类的属性与方法 ,一个类比较抽象的时候，就可以使用抽象类来概括</span></span><br><span class="line"><span class="comment">        作为抽象类的的类，只能被继承，不能作为子类，方法体不是必要的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Animal_new</span> </span>&#123;</span><br><span class="line">    eat (food: string): <span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`呼噜噜的吃：<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract run (distance: number): <span class="keyword">void</span> <span class="comment">// 抽象类中，如果定义的方法不具备方法体，应该使用抽象类关键词来修饰</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal_new</span> </span>&#123;</span><br><span class="line">    run(distance: number): <span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'四脚爬行'</span>, distance)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> chinese_rural_dog = <span class="keyword">new</span> Dog()</span><br><span class="line">chinese_rural_dog.eat(<span class="string">'骨头'</span>)</span><br><span class="line">chinese_rural_dog.run(<span class="number">100</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-8·泛型"><a href="#3-8·泛型" class="headerlink" title="3.8·泛型"></a>3.8·泛型</h2><blockquote><p>将声明的函数定义为一个常量，用的时候再去填写常量值，提升复用率</p></blockquote><ul><li><p>关键词：&lt;&gt;</p></li><li><p>说明：提高方法的复用率</p></li><li><p>实现逻辑:将函数的类型定义成为一个参数，当使用的时候，再去给参数赋值</p></li><li><p>格式示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* </span><br><span class="line">    泛型</span><br><span class="line">        关键词：&lt;&gt;</span><br><span class="line">        提高方法的复用率</span><br><span class="line">            实现逻辑:将函数声明的类型定义成为一个参数，当使用的时候，再去给参数赋值</span><br><span class="line">*&#x2F;</span><br><span class="line">function createArray&lt;T&gt; (length: number, value: T): T[] &#123; &#x2F;&#x2F; 通过泛型指定数据类型，提高代码的复用率</span><br><span class="line">    const arr &#x3D; Array&lt;T&gt;(length).fill(value)</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const res &#x3D; createArray&lt;string&gt;(3, &#39;foo&#39;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-9·类型声明处理第三方包"><a href="#3-9·类型声明处理第三方包" class="headerlink" title="3.9·类型声明处理第三方包"></a>3.9·类型声明处理第三方包</h2><blockquote><p>有些第三方包未经ts类型处理，需要处理，以便能够正常使用</p></blockquote><ul><li><p>关键词：declare</p></li><li><p>说明：主要用于兼容老的npm模块，目前大部分常用的npm包都有自己的类型声明模块，可以根据提示下载</p></li><li><p>格式示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* </span><br><span class="line">    类型声明 </span><br><span class="line">        关键词:  declare </span><br><span class="line">        说明：主要用于兼容老的npm模块，目前大部分常用的npm包都有自己的类型声明模块，可以根据提示下载</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 有类型声明模块的话下载引入类型声明模块包即可</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 拉钩大前端学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js异步处理学习笔记</title>
      <link href="/2020/05/23/js%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/23/js%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="异步编程是什么？"><a href="#异步编程是什么？" class="headerlink" title="异步编程是什么？"></a>异步编程是什么？</h1><blockquote><p>单线程JavaScript异步方案</p><ul><li><p>总所周知JavaScript是单线程的</p></li><li><p>采用单线程模式工作的原因</p><blockquote><p>最早是运行在浏览器端的脚本语言，目的就是用来实现页面中的动态交互，而实现页面交互的核心就是DOM操作，而这就决定了它必须使用单线程模型，否则就会出现很复杂的线程同步问题(举个🌰：多线程同时操作一个dom元素，一个删除一个修改，浏览器就无法判断应该以哪一个线程的结果为准)</p></blockquote></li><li><p>单线程的表现形式</p><ul><li>JS执行环境中负责执行代码的线程只有一个</li><li>先来后到排队，遇到一个超级耗时的任务，将严重影响后面的任务进程，出现假死的情况（异步应运而生）</li></ul></li></ul></blockquote><h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><ul><li>同步模式与异步模式</li><li>事件循环与消息队列</li><li>异步编程的几种方式</li><li>Promise异步方案、宏任务/微任务队列</li><li>Generator异步方案、Async/Await语法糖</li></ul><h1 id="1·同步模式与异步模式"><a href="#1·同步模式与异步模式" class="headerlink" title="1·同步模式与异步模式"></a>1·同步模式与异步模式</h1><blockquote><p>JavaScript将任务的执行模式分成了两种</p></blockquote><ul><li>同步模式(Synchronous)</li><li>异步模式(Asynchronous)</li></ul><blockquote><p>根据运行环境提供的API是以同步还是异步模式的方式工作来区分</p></blockquote><h2 id="1-1·同步模式"><a href="#1-1·同步模式" class="headerlink" title="1.1·同步模式"></a>1.1·同步模式</h2><blockquote><p>​    代码中的任务依次执行，后面的任务必须等待前面的任务执行结束，才能开始执行，代码中的大多数任务采取的是同步执行模式</p></blockquote><h2 id="1-2·异步模式"><a href="#1-2·异步模式" class="headerlink" title="1.2·异步模式"></a>1.2·异步模式</h2><blockquote><p>​    异步模式下，不会去等待一个任务的结束才开始下一个任务。对于耗时的任务，在开启过后就会立即往后执行下一个任务，后续逻辑一般会通过回调函数的方式去定义(耗时任务在内部执行完成之后就会执行回调)。</p></blockquote><ul><li><p>如果没有异步执行模式，单线程的JavaScript就无法同时处理大量的耗时任务</p></li><li><p>异步执行会遇到的问题</p><ul><li><p>代码的执行顺序混乱</p><blockquote><p>众多面试题的设计灵感来源。</p></blockquote></li></ul></li><li><p>JavaScript是单线程的，但是浏览器并非是单线程的，浏览器内部的API会有单独的线程去执行这些耗时的操作</p></li></ul><blockquote><p>逻辑过程中的名称:</p><p>​    Call stack: 执行栈，调用栈</p><p>​    Web APIs:用于罗列异步任务</p><p>​    Queue:消息队列，给异步任务排序</p><p>​    Event loop:事件循环机制，当调用栈为空的时候，依次将消息队列中的函数任务调往执行栈</p><p>逻辑总结:</p><p>​    在代码执行的过程中，执行栈先进行压栈（控制执行栈不为空，暂不调用消息队列），在遇到同步任务的时候放到执行栈中并执行，在遇到异步任务的时候，先罗列到Web APIs中。待同步任务全部执行完毕之后，撤销压栈，将罗列的异步任务按时间先后在消息队列中排列，通过事件循环机制依次调到执行栈并执行，遇到新的异步任务的时候，可以根据时间在消息队列中进行加塞。</p></blockquote><p><img src="https://pics.images.ac.cn/image/5ec40ff668b7e.html" alt="逻辑图解"></p><h1 id="2·回调函数"><a href="#2·回调函数" class="headerlink" title="2·回调函数"></a>2·回调函数</h1><blockquote><p>回调函数：</p><p>​    所有异步编程方案(为js异步而生的语法)的根基</p><p>​    调用者定义回调函数，执行栈执行这个函数，其实就是调用者告诉执行者异步任务结束之后应该做什么</p></blockquote><ul><li><p>最基本的回调方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    最早的回调函数</span></span><br><span class="line"><span class="comment">        通过传递回调参数实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        callback()</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数，并传递回调参数</span></span><br><span class="line">foo(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这就是一个回调函数，调用者定义这个函数，执行栈执行这个函数，其实就是调用者告诉执行者异步任务结束之后应该做什么'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h1 id="3·Promise异步方案"><a href="#3·Promise异步方案" class="headerlink" title="3·Promise异步方案"></a>3·Promise异步方案</h1><blockquote><p>Promise(承诺)：</p><p>​    一种更优的异步编程统一方案</p><p>解决的痛点：</p><p>​    传统的回调方式无法完成复杂的回调逻辑，会造成回调地狱的情况</p><p>CommonJS社区首次提出了Promise的规范用于解决回调地狱，在ES2015中被标准化，成为语言规范</p><p>概念：</p><p>​    君子一诺千金，Promise的回调拥有两种，失败与成功，定义了成功如何，失败又如何的行事原则。</p></blockquote><h2 id="3-1·Promise的基本用法"><a href="#3-1·Promise的基本用法" class="headerlink" title="3.1·Promise的基本用法"></a>3.1·Promise的基本用法</h2><blockquote><p>Promise代码层面的基本使用</p><p>Promise也可以说是ES2015所提供的一个<strong>全局类型</strong>，可以通过它来实例出新的承诺</p></blockquote><ul><li><p>Promise的注意点：</p><ul><li>无论成败，都应有回应</li><li>无论成败，都不可逆</li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Promise的基本使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 这个类型的函数和以往的有些与不同，它需要接收一个函数(兑现承诺的逻辑)作为参数</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里用来'兑现'承诺</span></span><br><span class="line"></span><br><span class="line">    resolve(<span class="string">'条件达成了'</span>) <span class="comment">// 承诺达成 输出结果：resolved 条件达成了</span></span><br><span class="line"></span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'promise rejected'</span>)) <span class="comment">// 承诺失败 输出结果：rejected Error: promise rejected</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化处理啊的承诺，可以通过then来获取回应。</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'resolved'</span>, value) <span class="comment">// 返回成功的回应</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected'</span>, error) <span class="comment">// 返回失败的回应</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 承诺的注意点：</span></span><br><span class="line"><span class="comment">//     无论失败与成功，都有其对应的回应</span></span><br><span class="line"><span class="comment">//     无论成功或者失败，结果不可逆</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2·Promise的使用案例"><a href="#3-2·Promise的使用案例" class="headerlink" title="3.2·Promise的使用案例"></a>3.2·Promise的使用案例</h2><blockquote><p>Promise 方式的 AJAX</p></blockquote><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Promise 方式的 AJAX</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>, url)</span><br><span class="line">        xhr.responseType = <span class="string">'json'</span></span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(<span class="keyword">this</span>.response) <span class="comment">// 承诺成功达成之后，返回得到的数据</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText)) <span class="comment">// 承诺无法达成之后，返回new出来的错误信息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务</span></span><br><span class="line">ajax(<span class="string">'./api/foo.json'</span>)</span><br><span class="line">    .then( <span class="comment">// 默认函数第一个成功，第二个失败</span></span><br><span class="line">        <span class="comment">// 承诺成功达成,对于返回的成功信息的处理</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res) <span class="comment">// 成功之后，朴实无华的打印出来获取到的数据 (2) [&#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 承诺失信了，对于失败的返回信息的处理</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error) <span class="comment">// 返回失败信息</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-3·Promise链式调用"><a href="#3-3·Promise链式调用" class="headerlink" title="3.3·Promise链式调用"></a>3.3·Promise链式调用</h2><blockquote><p>不同以往的链式调用：</p><p>​    通过then的处理，返回处理过后的promise，从而解决回调地狱问题</p></blockquote><ul><li><p>链式调用</p><ul><li>Promise对象的then方法会返回一个全新的Promise对象</li><li>后面的then方法就是在为上一个then返回的peomise注册回调</li><li>then的return返回内容<ul><li>无返回值，则操作的就是上一个处理过后的</li><li>类型依旧为<code>promise</code>,则下一个then处理的就是返回的这个,并且会排队等待返回的promise结束之后再处理</li><li>并非<code>promise</code>类型，则是下一个then的参数</li></ul></li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Promise链式调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个类型的函数和以往的有些与不同，它需要接收一个函数(兑现承诺的逻辑)作为参数</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里用来'兑现'承诺</span></span><br><span class="line"></span><br><span class="line">    resolve(<span class="string">'条件达成了'</span>) <span class="comment">// 承诺达成 输出结果：resolved 条件达成了</span></span><br><span class="line"></span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'promise rejected'</span>)) <span class="comment">// 承诺失败 输出结果：rejected Error: promise rejected</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化处理啊的承诺，可以通过then来获取回应。</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'resolved'</span>, value) <span class="comment">// 返回成功的回应</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected'</span>, error) <span class="comment">// 返回失败的回应</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取通过then处理一次过后的返回值</span></span><br><span class="line"><span class="keyword">var</span> promise2 = promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'resolved'</span>, value) <span class="comment">// 返回成功的回应</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected'</span>, error) <span class="comment">// 返回失败的回应</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    在以往我们使用链式调用，是因为使用的方法没有改变this执行，就是说经过某个方法，返回的依旧是原本的对象本身</span></span><br><span class="line"><span class="comment">    但是，</span></span><br><span class="line"><span class="comment">        promise中，通过then处理的promise并不是原来的promise，而这也正是promise链式调用的关键所在</span></span><br><span class="line"><span class="comment">        通过then的处理，返回处理过后的promise，从而解决回调地狱问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(promise === promise2) <span class="comment">// 返回结果：false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于then的返回值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------------------------------------------------'</span>)</span><br><span class="line">promise</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 无返回值</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'无返回值'</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(value)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'返回一个promise类型的数据'</span>)</span><br><span class="line">            <span class="keyword">return</span> promise</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'在这次回调中返回一个非promise类型的数据'</span>)</span><br><span class="line">            <span class="keyword">return</span> value + <span class="string">'并在此返回一个非promise类型的数据'</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'接收一个非promise类型的数据: '</span> + value)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-4·Promise异常处理"><a href="#3-4·Promise异常处理" class="headerlink" title="3.4·Promise异常处理"></a>3.4·Promise异常处理</h2><blockquote><p>处理异常的三种方式</p></blockquote><ul><li><p>异常的回调函数</p><ul><li>then的第二个函数</li><li>紧跟在每一个then后面的catch</li><li>全局对象的unhandledrejection统一处理（不推荐使用）<ul><li>推荐在代码中明确的捕获每一个可能的异常</li></ul></li></ul></li><li><p>前两种回调方法的不同点</p><ul><li>then的第二个函数只捕获上一个promise的错误</li><li>catch捕获前面的所有promise的错误</li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Promise异常处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>, url)</span><br><span class="line">        xhr.responseType = <span class="string">'json'</span></span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(<span class="keyword">this</span>.response) <span class="comment">// 承诺成功达成之后，返回得到的数据</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText)) <span class="comment">// 承诺无法达成之后，返回new出来的错误信息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务</span></span><br><span class="line">ajax(<span class="string">'./api/foo.json'</span>)</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">            <span class="comment">// 返回一个错误的promise</span></span><br><span class="line">            <span class="keyword">return</span> ajax(<span class="string">'./api/abel.json'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error + <span class="string">' 离太近了，不好意思抓'</span>) <span class="comment">// 并没有捕获上面的异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"><span class="comment">// catch处理错误</span></span><br><span class="line">ajax(<span class="string">'./api/foo.json'</span>)</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">err</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">            <span class="comment">// 返回一个错误的promise</span></span><br><span class="line">            <span class="keyword">return</span> ajax(<span class="string">'./api/abel.json'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 本质就是紧跟着的then中的promise的回调</span></span><br><span class="line">    .catch(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error + <span class="string">' 小样，哪里跑'</span>) <span class="comment">// 结果输出：Error: Not Found 小样，哪里跑</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    全局对象错误统一处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// Web中</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unhandledrejection'</span>, event =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; reason, promise &#125; = event</span><br><span class="line">    <span class="built_in">console</span>.log(reason, promise)</span><br><span class="line">    <span class="comment">// reason =&gt; Promise</span></span><br><span class="line">    <span class="comment">// promise =&gt; 出现异常的Promise对象</span></span><br><span class="line">    event.preventDefault()</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// node中</span></span><br><span class="line">process.on(<span class="string">'unhandledRejection'</span>, (reason, promise) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason, promise)</span><br><span class="line">    <span class="comment">// reason =&gt; Promise</span></span><br><span class="line">    <span class="comment">// promise =&gt; 出现异常的Promise对象</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-5·Promise静态方法"><a href="#3-5·Promise静态方法" class="headerlink" title="3.5·Promise静态方法"></a>3.5·Promise静态方法</h2><blockquote><p>Promise相关的方法</p></blockquote><ul><li><p>Promise.resolve()</p><ul><li>将任意参数变为promise</li><li>根据传入类型的不同，有不同的效果与意义<ul><li>传入字符串等类型的，属于作为参数，传给了自己的回调函数</li><li>传入一个promise,等于promise本身</li><li>传入一个拥有then方法的对象，第三方promise转原生promise的解决方案</li></ul></li></ul></li><li><p>Promise.reject()</p><ul><li>快速创建一个承诺未达成的原因</li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Promise静态方法  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Promise.resolve()</span></span><br><span class="line"><span class="comment">        将任意的参数变为promise</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 传入字符串等类型的，属于作为参数，传给了自己的回调函数</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line">foo</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(value) <span class="comment">// 结果输出：foo</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"><span class="comment">// 传入一个promise,等于promise本身</span></span><br><span class="line"><span class="keyword">const</span> foo1 = <span class="built_in">Promise</span>.resolve(foo)</span><br><span class="line">foo1</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(value) <span class="comment">// 结果输出：foo</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"><span class="comment">// 传入一个拥有then方法的对象，第三方promise转原生promise的解决方案</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">    then: <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">        onFulfilled(<span class="string">'foo'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value) <span class="comment">// 结果输出：foo</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Promise.reject()</span></span><br><span class="line"><span class="comment">        快速创建一个失败的原因</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'这就是我失败理由'</span>)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error) <span class="comment">// 结果输出：这就是我失败理由</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-6·Promise并行执行"><a href="#3-6·Promise并行执行" class="headerlink" title="3.6·Promise并行执行"></a>3.6·Promise并行执行</h2><blockquote><p>齐头并进的Promise</p></blockquote><ul><li><p>Promise.all()</p><ul><li>我全都要</li></ul></li><li><p>Promise.race()</p><ul><li>只要一个就好</li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Promise并行执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>, url)</span><br><span class="line">        xhr.responseType = <span class="string">'json'</span></span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(<span class="keyword">this</span>.response) <span class="comment">// 承诺成功达成之后，返回得到的数据</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText)) <span class="comment">// 承诺无法达成之后，返回new出来的错误信息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------</span></span><br><span class="line"><span class="comment">/* 如何判断都结束了</span></span><br><span class="line"><span class="comment">    之前：计数器</span></span><br><span class="line"><span class="comment">    现在：all</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Promise.all()</span></span><br><span class="line"><span class="comment">        将多个promise合并，一荣俱荣一损俱损</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.all(</span><br><span class="line">    [</span><br><span class="line">        ajax(<span class="string">'./api/foo.json'</span>),</span><br><span class="line">        ajax(<span class="string">'./api/foo.json'</span>)        </span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">promise</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">values</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(values) <span class="comment">// 结果输出：(2) [Array(2), Array(2)] // 返回all里面promise返回的内容，组成的数组</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error) <span class="comment">// 但凡有一个出错，就会报错</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Promise.race()</span></span><br><span class="line"><span class="comment">        弱水三千只取一瓢，只要有完成的就不再等待其他的异步任务了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> request = ajax(<span class="string">'./api/posts.json'</span>)</span><br><span class="line"><span class="keyword">const</span> timeout = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'timeout'</span>)), <span class="number">500</span>)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">    request,</span><br><span class="line">    timeout</span><br><span class="line">])</span><br><span class="line">    .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value) <span class="comment">// 输出结果：返回最早完成的异步任务，可以在开发者工具中更改网速来体验</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    混合使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ajax.apply(<span class="string">'./api/urls/json'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> urls = <span class="built_in">Object</span>.values(value)</span><br><span class="line">        <span class="keyword">const</span> tasks = urls.map(<span class="function"><span class="params">url</span> =&gt;</span> ajax(url))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.all(tasks)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">valuse</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(values)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-7·Promise执行时序"><a href="#3-7·Promise执行时序" class="headerlink" title="3.7·Promise执行时序"></a>3.7·Promise执行时序</h2><blockquote><p>宏任务 &amp; 微任务</p></blockquote><ul><li><p>宏任务</p><ul><li>跟在宏任务后面，如果有格外的需求，可以跟着一起办理，无需重新排队，提高整体的响应能力</li><li>Promise &amp; MutationObserver &amp; process.nextTick(node环境中)</li></ul></li><li><p>微任务</p><ul><li>目前绝大多数异步调用都是作为宏任务执行，需要重新排队</li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Promise执行时序</span></span><br><span class="line"><span class="comment">        宏任务&amp;微任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    微任务: 跟在宏任务后面，如果有格外的需求，可以跟着一起办理，无需重新排队，提高整体的响应能力</span></span><br><span class="line"><span class="comment">        Promise &amp; MutationObserver &amp; process.nextTick(node环境中)</span></span><br><span class="line"><span class="comment">    宏任务：目前绝大多数异步调用都是作为宏任务执行，需要重新排队</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'开始执行同步任务'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是一个定时器异步任务'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise中的第一个回调'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise中的第二个回调'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise中的第三个回调'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'同步任务结束'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果顺序</span></span><br><span class="line"><span class="comment">        开始执行同步任务</span></span><br><span class="line"><span class="comment">        同步任务结束</span></span><br><span class="line"><span class="comment">        promise中的第一个回调</span></span><br><span class="line"><span class="comment">        promise中的第二个回调</span></span><br><span class="line"><span class="comment">        promise中的第三个回调</span></span><br><span class="line"><span class="comment">        这是一个定时器异步任务</span></span><br><span class="line"><span class="comment">    疑问点：</span></span><br><span class="line"><span class="comment">        1.为什么promise比定时器任务更先执行</span></span><br><span class="line"><span class="comment">            由于promise本身可以作为微任务，因此，它拥有比定时器更优先的时序排列。</span></span><br><span class="line"><span class="comment">        2.为什么promise的回调的回调都跟着提前了</span></span><br><span class="line"><span class="comment">            答：回调队列中的任务称之为宏任务，而宏任务执行过程中临时加上的额外需求成为微任务，可以直接跟着执行，无需排队，当然也可以选择作为一个新的宏任务进入到队列中排队</span></span><br><span class="line"><span class="comment">            追问：什么异步任务能重新选择作为宏任务，什么能作为微任务跟着执行</span></span><br><span class="line"><span class="comment">            答：定时器任务会做回宏任务从新排队，而promise的回调会作为微任务跟着执行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-8·Promise常见误区"><a href="#3-8·Promise常见误区" class="headerlink" title="3.8·Promise常见误区"></a>3.8·Promise常见误区</h2><blockquote><p>Promise的本质也是通过回调函数，来定义异步任务结束之后所需要执行的任务</p></blockquote><p>注意点：</p><ul><li>Promise回调方法，通过 <code>then</code> 来传递</li><li>Promise分为成功与失败的回调</li><li>Promise无需嵌套使用,通过链式调用，来保持异步的扁平化</li><li>宏任务与微任务对于执行顺序的影响</li></ul><h1 id="4·Generator异步方案"><a href="#4·Generator异步方案" class="headerlink" title="4·Generator异步方案"></a>4·Generator异步方案</h1><blockquote><p>进一步提升异步任务的代码可读性</p></blockquote><h2 id="4-1·Generator-异步解决方案回顾"><a href="#4-1·Generator-异步解决方案回顾" class="headerlink" title="4.1·Generator 异步解决方案回顾"></a>4.1·Generator 异步解决方案回顾</h2><blockquote><p>ES2015Generator的回顾与补充</p></blockquote><ul><li><p>在普通函数的函数名前面加<code>*</code> ,可以把普通函数变为生成器函数</p></li><li><p>生成器函数的函数体，通过next()调用后才能执行</p></li><li><p><code>yield</code>关键词，打断点</p></li><li><p><code>throw()</code>用于返回错误,可以被函数体中的try…catch捕获到</p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Generator 异步解决方案回顾</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">yield</span> <span class="string">'foo'</span></span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = foo()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// 在生成器函数中，遇到yield会在执行完这一个yield之后暂停 // 输出结果：&#123;value: "foo", done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抛出了一个错误'</span>))) <span class="comment">// throw同样可以继续执行，不过打印出来的会是错误信息 // 输出结果：Error: 抛出了一个错误</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-2·体验Generator异步方案"><a href="#4-2·体验Generator异步方案" class="headerlink" title="4.2·体验Generator异步方案"></a>4.2·体验Generator异步方案</h2><blockquote><p>使用Generator的特性来体验更优的异步解决方案</p></blockquote><ul><li><p>逻辑分析</p><blockquote><p>Generator用于异步方案，得益于它的关键词yield后面的返回值，value，将作为参数传递下去，这符合了promise链式的需求，每一次通过调用next()才能继续往下进行，这给了用于反馈每次异步请求的回调函数以执行的控件，通过在生成器中指定try…catch，在执行时调用throw()方法也可以捕获异常，再通过自调用迭代，就可以完成异步请求的进一步扁平化，如同步函数一样。</p></blockquote></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    体验Generator异步方案</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>, url)</span><br><span class="line">        xhr.responseType = <span class="string">'json'</span></span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(<span class="keyword">this</span>.response) <span class="comment">// 承诺成功达成之后，返回得到的数据</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText)) <span class="comment">// 承诺无法达成之后，返回new出来的错误信息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">main</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> foo = <span class="keyword">yield</span> ajax(<span class="string">'./api/foo.json'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(foo)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">const</span> posts = <span class="keyword">yield</span> ajax(<span class="string">'./api/posts.json'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(posts)</span><br><span class="line">        <span class="comment">// 创造一个异常</span></span><br><span class="line">        <span class="keyword">const</span> postt = <span class="keyword">yield</span> ajax(<span class="string">'./api/postt.json'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(postt)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = main() <span class="comment">// 创建生成器函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">generator初体验</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// result.value =&gt; 返回的就是yield后面的promise异步任务</span></span><br><span class="line"><span class="comment">/* const result = g.next() // 进入函数体</span></span><br><span class="line"><span class="comment">    result.value</span></span><br><span class="line"><span class="comment">    .then(data =&gt; &#123;</span></span><br><span class="line"><span class="comment">        // console.log(data) // data就是上一次触发next()触发的异步请求的结果 // 输出结果：foo.json文件的内容</span></span><br><span class="line"><span class="comment">        // 将上一个异步请求的结果作为参数，传给下一个promise,符合了promise的链式调用</span></span><br><span class="line"><span class="comment">        const result2 = g.next(data)</span></span><br><span class="line"><span class="comment">        // 判断返回内容，done是否为true，决定是否结束</span></span><br><span class="line"><span class="comment">        if (result2.done) return console.log('结束了')</span></span><br><span class="line"><span class="comment">        // 处理第二个promise的回调</span></span><br><span class="line"><span class="comment">        result2.value</span></span><br><span class="line"><span class="comment">            .then(data =&gt; &#123;</span></span><br><span class="line"><span class="comment">                const result3 = g.next(data)</span></span><br><span class="line"><span class="comment">                if (result3.done) return console.log('结束了')</span></span><br><span class="line"><span class="comment">                // ...... 无限循环嵌套,因此需要递归解决</span></span><br><span class="line"><span class="comment">            &#125;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;) */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    递归执行generator</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 定于一个函数，用来递归执行generator</span></span><br><span class="line"><span class="comment">/* function handleResult  (result) &#123;</span></span><br><span class="line"><span class="comment">    if (result.done) return // 生成器函数结束</span></span><br><span class="line"><span class="comment">    result.value</span></span><br><span class="line"><span class="comment">        .then(data =&gt; &#123;</span></span><br><span class="line"><span class="comment">             handleResult(g.next(data)) // 嵌套使用，如果进入到这一步，相当于又重新调用了一下这个函数</span></span><br><span class="line"><span class="comment">        &#125;, error =&gt; &#123;</span></span><br><span class="line"><span class="comment">            g.throw(error) // 打印异常的话，需要改造generator,添加try...catch用来处理异常 // 打印结果：Error: Not Found at XMLHttpRequest.xhr.onload (10.js:14)</span></span><br><span class="line"><span class="comment">        &#125;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">handleResult(g.next()) */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    复用生成器函数 ： co</span></span><br><span class="line"><span class="comment">        https://github.com/tj/co // 社区中关于generato生成器复用函数的完整的库</span></span><br><span class="line"><span class="comment">        被Async await 取代</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span> (<span class="params">generator</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> g = generator()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleResult</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span></span><br><span class="line">        result.value</span><br><span class="line">            .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                handleResult(g.next(data)) <span class="comment">// 循环调用</span></span><br><span class="line">            &#125;, error =&gt; &#123;</span><br><span class="line">                g.throw(error)</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  内部自调用</span></span><br><span class="line">    handleResult(g.next())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入一个generator</span></span><br><span class="line">co(main)</span><br></pre></td></tr></table></figure></li></ul><h1 id="5·Async语法糖"><a href="#5·Async语法糖" class="headerlink" title="5·Async语法糖"></a>5·Async语法糖</h1><blockquote><p>终极的异步解决方案。</p><p>语言层面的异步编程标准</p></blockquote><ul><li><p>语法类似于generator</p><ul><li>关键词从<code>*&amp;yield</code>变成了<code>async &amp; await</code></li><li>目前<code>await</code>无法单独使用，只能在async定义的函数中使用</li></ul></li><li><p>使用Async修饰的函数，返回的也是一个promise</p></li><li><p>不再需要配合执行器，直接调用修饰的函数，就是执行的全部过程</p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Async语法糖</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    终极的异步解决方案。</span></span><br><span class="line"><span class="comment">    语言层面的异步编程标准</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    语法类似于generator</span></span><br><span class="line"><span class="comment">    返回一个promise</span></span><br><span class="line"><span class="comment">    不再需要配合执行器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>, url)</span><br><span class="line">        xhr.responseType = <span class="string">'json'</span></span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(<span class="keyword">this</span>.response) <span class="comment">// 承诺成功达成之后，返回得到的数据</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText)) <span class="comment">// 承诺无法达成之后，返回new出来的错误信息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> foo = <span class="keyword">await</span> ajax(<span class="string">'./api/foo.json'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(foo)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">const</span> posts = <span class="keyword">await</span> ajax(<span class="string">'./api/posts.json'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(posts)</span><br><span class="line">        <span class="comment">// 创造一个异常</span></span><br><span class="line">        <span class="keyword">const</span> postt = <span class="keyword">await</span> ajax(<span class="string">'./api/postt.json'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(postt)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></li></ul><p>​    generator.throw() 用于抛出异常</p>]]></content>
      
      
      <categories>
          
          <category> 拉钩大前端学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript新特性学习笔记</title>
      <link href="/2020/05/18/ECMAScript%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/18/ECMAScript%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><blockquote><p>Q：为什么要学习<a href="http://www.ecma-international.org/" target="_blank" rel="noopener">ECMAScript</a>?</p><p>A：</p><ul><li>1.很多前端开发者并没理解语言和平台之间的关系。</li><li>2.对ES的理解和掌握程度都不尽相同，在开展后面的课程之前，系统化的学习ECMAScript很有必要。</li><li>是我们能够写出更现代化，更高质量的代码</li></ul></blockquote><h3 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h3><ul><li>ECMAScript与JavaScript</li><li>ECMAScript的发展过程</li><li>ECMAScript2015的新特性</li><li>And more…</li></ul><h2 id="1·ECMAScript概述"><a href="#1·ECMAScript概述" class="headerlink" title="1·ECMAScript概述"></a>1·ECMAScript概述</h2><ul><li><p>JavaScript<strong>语言本身</strong>指的就是ECMAScript，是一门脚本语言</p></li><li><p>ES通常看作是JS的<strong>标准化规范</strong>，但实际上JS是ES的<strong>扩展语言</strong></p><ul><li><p>ES只提供了最基本的<strong>语法</strong>,约定代码该如何编写 </p></li><li><p>JS在ES语言标准的基础上，做出扩展，使我们在web浏览器环境下，可以操作BOM和DOM</p></li><li><p>JS在浏览器环境中(Web) = ES + Web APIs</p><p><img src="https://pics.images.ac.cn/image/5ebc08c8b8fad.html" alt="JavaScript与ES的关系"></p></li><li><p>在Node环境中(Node.js)，可以做一些读写文件之类的操作</p></li><li><p>JS在Node环境中 = ES + Node APIs </p><p><img src="https://pics.images.ac.cn/image/5ebc0986e3494.html" alt="JS与node.js的关系"></p></li></ul></li></ul><h2 id="2·ES2015的学习"><a href="#2·ES2015的学习" class="headerlink" title="2·ES2015的学习"></a>2·ES2015的学习</h2><blockquote><p>Q：为什么要学习<a href="http://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">ES2015</a>？</p><p>A:</p><ul><li><strong>新特性</strong>(颠覆性功能)较多———本模块学习的主要内容</li><li>按版本号也称ES6，ES2015开始按年份命名<ul><li>也有很多人喜欢用ES6泛指所有的新标准</li></ul></li></ul></blockquote><h3 id="变化概要"><a href="#变化概要" class="headerlink" title="变化概要"></a>变化概要</h3><blockquote><p>ES2015相对于之前版本的主要变化</p><p>学习目标 🚩 ：在学习完本模块之后，需要根据这几个概要用自己的话描述出来</p></blockquote><ul><li>解决原有语法上的一些问题或者不足</li><li>对原有语法进行增强</li><li>全新的对象，全新的方法，全新的功能</li><li>全新的数据类型和数据结构</li></ul><h3 id="2-1·let、const与块级作用域"><a href="#2-1·let、const与块级作用域" class="headerlink" title="2.1·let、const与块级作用域"></a>2.1·let、const与块级作用域</h3><ul><li><p><strong>作用域</strong></p><blockquote><p>某个成员能够起作用的范围</p></blockquote><ul><li><p>作用域的分类</p><blockquote><p>ES2015新增<strong>块级作用域</strong></p><ul><li>块：一对花括号所包裹的范围</li></ul></blockquote><ul><li><p>全局作用域</p></li><li><p>函数作用域</p></li><li><p>块级作用域</p><blockquote><p>引入的原因(痛点):</p><ol><li>以前块没有独立的作用域，因此定义在函数里面的变量，外边也能访问到</li></ol></blockquote></li></ul></li></ul></li><li><p><strong>let</strong></p><blockquote><p>新的声明变量的关键词</p></blockquote><ul><li><p>特性</p><ul><li><p>支持块级作用域</p><ul><li>内部声明的变量，外部无法访问</li></ul></li><li><p>变量声明不会提升</p><blockquote><p>什么是变量声明提升(痛点):</p><p>在函数后面声明的方法，却能调用到之后用var声明的变量，违背了代码执行从上到下的原则</p></blockquote></li></ul></li></ul></li><li><p>const</p><blockquote><p>恒量/常量</p><p>在let的基础上再次做出升级</p></blockquote><ul><li>特性<ul><li>支持块级作用域<ul><li>内部声明的变量，外部无法访问</li></ul></li><li>变量声明不会提升</li><li>只读<ul><li>声明后不可再做出修改</li></ul></li></ul></li></ul></li></ul><p><strong>最佳实践</strong>，关于声明变量的关键词的使用</p><blockquote><p>不用var，主用const，配合let</p></blockquote><h3 id="2-2·解构赋值"><a href="#2-2·解构赋值" class="headerlink" title="2.2·解构赋值"></a>2.2·解构赋值</h3><blockquote><p>分别针对字符串数组，对象的解构赋值</p><p>以数组的解构赋值为基础，字符串与对象的解构赋值相同内容不做解释</p></blockquote><ul><li><p>数组的解构赋值</p><blockquote><p>以下为特性介绍</p></blockquote><ul><li><p>基本的解构赋值</p><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个数组</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">---------------------------</span><br><span class="line"><span class="keyword">const</span> [ a, b, c, d ] = arr <span class="comment">// 一对一按顺序匹配,没有匹配到的返回undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a,b,c,d)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>支持空格占位</p><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ , , c] = arr</span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>剩余参数<code>...</code></p><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ a, ...rest] = arr <span class="comment">// 只能解构赋值的最后一个使用</span></span><br><span class="line"><span class="built_in">console</span>.log(...rest) <span class="comment">// 参数单独输出</span></span><br><span class="line"><span class="built_in">console</span>.log(rest) <span class="comment">// 以数组的格式输出</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>默认值</p><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ a, b = <span class="number">3</span>, c, d = <span class="number">5</span>] = arr</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"b的默认值为3,解构赋值为:"</span> + b)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"d的默认值为5,解构赋值为:"</span> + d) <span class="comment">// 默认值会被替换,如果数组中存在相应的位置的值的话</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>字符串的解构赋值</p><blockquote><p>基本与数组的解构赋值一样</p></blockquote><ul><li><p>基本的解构赋值</p><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c,d,e)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>支持空格占位</p></li><li><p>剩余参数<code>...</code></p></li><li><p>默认值</p></li></ul><blockquote><p>经典的应用场景</p><p>字符串的分割</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">'a/b/c'</span></span><br><span class="line"><span class="keyword">const</span> [ ...rootdir ] = path.split(<span class="string">'/'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(rootdir)</span><br></pre></td></tr></table></figure></blockquote></li><li><p>对象的解构赋值</p><blockquote><p>相比于数组的解构赋值，多了一个起别名</p><p>但是没有空格占位，因为对象本身就是无序的</p></blockquote><ul><li><p>基本的解构赋值</p><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">'abel'</span>, <span class="attr">sex</span>: <span class="string">'男'</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>剩余参数<code>...</code></p></li><li><p>默认值</p></li><li><p>起别名</p><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原本的属性名将会被顶替,无法使用</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: Name &#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'我的名字是:'</span> + Name)</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>经典的应用场景</p><p>解构常用的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span></span><br><span class="line">log(<span class="string">'abc'</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="2-3·模板字符串"><a href="#2-3·模板字符串" class="headerlink" title="2.3·模板字符串"></a>2.3·模板字符串</h3><blockquote><p>相对于传统字符串的特性</p></blockquote><ul><li><p>模板字符串</p><ul><li><p>支持换行符</p><blockquote><p>支持标签的嵌入组合</p></blockquote><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = </span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>支持插值表达式<code>${}</code></p><blockquote><p>插值表达式支持变量，运算，方法等</p></blockquote><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'abel'</span></span><br><span class="line"><span class="keyword">const</span> math = <span class="function"><span class="keyword">function</span> (<span class="params">year</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> year/<span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> msg = <span class="string">`My name is <span class="subst">$&#123; name &#125;</span>. Next year will be <span class="subst">$&#123; <span class="number">23</span> + <span class="number">1</span> &#125;</span>.  24 is several times 12?: <span class="subst">$&#123; math(<span class="number">24</span>) &#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.log(msg)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>带标签的模板字符串</p><blockquote><p>模板字符串的加工</p></blockquote><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'abel'</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">23</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAge</span> (<span class="params">strings, name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// strings 第一个参数接收所有的以插值表达式分割的字符串内容,并以数组的形式返回</span></span><br><span class="line">    <span class="comment">// console.log(strings, name, age)</span></span><br><span class="line">    <span class="comment">// 返回内容:</span></span><br><span class="line">    <span class="comment">// [ 'my name is ', ", I'm ", " years old , I'll be 28 in five years" ] abel 23</span></span><br><span class="line">    <span class="comment">// ---------------------</span></span><br><span class="line">    <span class="keyword">return</span> strings[<span class="number">0</span>] + name + strings[<span class="number">1</span>] + age + strings[<span class="number">2</span>] + <span class="string">`I'll be <span class="subst">$&#123; age + <span class="number">5</span> &#125;</span> in five years `</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = myAge<span class="string">`my name is <span class="subst">$&#123; name &#125;</span>, I'm <span class="subst">$&#123; age &#125;</span> years old.`</span></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">// 返回内容</span></span><br><span class="line"><span class="comment">// my name is abel, I'm 23 years old.I'll be 28 in five years</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="2-4·字符串的扩展方法"><a href="#2-4·字符串的扩展方法" class="headerlink" title="2.4·字符串的扩展方法"></a>2.4·字符串的扩展方法</h3><blockquote><p>ES2015新增方法关于字符串</p></blockquote><ul><li><p>includes()</p><blockquote><p>判断是否包含</p></blockquote><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>startsWith()</p><blockquote><p>判断是否以指定字段开头</p></blockquote><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">'Error'</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>endsWith()</p><blockquote><p>判断是否以指定字段结尾</p></blockquote><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">'.'</span>))</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-5·函数形参列表的扩展方法"><a href="#2-5·函数形参列表的扩展方法" class="headerlink" title="2.5·函数形参列表的扩展方法"></a>2.5·函数形参列表的扩展方法</h3><blockquote><p>给函数的形参列表定义方法，帮助函数内部对于形参的处理</p></blockquote><ul><li><p>参数默认值</p><blockquote><p><code>||</code>短路运算的方式局限性大，很多情况不可以使用</p><p>判断是否未定义较为麻烦</p></blockquote><ul><li><p>格式示例</p><blockquote><p>带有默认值的形参应该放在后面</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msg</span> (<span class="params">name, age = <span class="number">0</span>, sex = <span class="string">'女'</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'my name is '</span> + name + <span class="string">',age:'</span> + age + <span class="string">',sex:'</span> + sex)</span><br><span class="line">&#125;</span><br><span class="line">msg(<span class="string">'abel'</span>,<span class="number">23</span>,<span class="string">'男'</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>剩余参数<code>...</code></p><blockquote><p>在之前，我们使用arguments对象（伪数组）来接收数量不明的参数。</p></blockquote><ul><li><p>格式示例</p><blockquote><p>接收剩余的所有参数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a, b, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a,b,args) <span class="comment">//输出结果:1 2 [ 4, 5, 6, 7, 8, 9 ]</span></span><br><span class="line">    <span class="comment">// 展开运算符的体验</span></span><br><span class="line">    <span class="built_in">console</span>.log(a,b,...args) <span class="comment">//输出结果:1 2 4 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)</span><br></pre></td></tr></table></figure></li><li><p>关于<code>...</code>的另一项功能</p><blockquote><p>也被用于进行展开数组，因此也称为<strong>展开运算符</strong></p><p>以往如何展开(痛点)：</p><ul><li>根据下标依次输出</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>apply改变指向来输出</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, arr)</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><ul><li><p>格式示例</p><blockquote><p>极为简便的展开数组</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(...arr) <span class="comment">// 输出结果:foo bar baz</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="2-6·箭头函数"><a href="#2-6·箭头函数" class="headerlink" title="2.6·箭头函数"></a>2.6·箭头函数</h3><blockquote><p>全新的函数声明方式</p><p>关于箭头函数，<code>=&gt;</code> 等字体显示的优化展示：FiraCode字体</p></blockquote><ul><li><p>简化函数定义</p><ul><li><p>基础格式的优化</p></li><li><p>回调函数的优化(常用，推荐使用)</p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统函数定义:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inc</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//箭头函数</span></span><br><span class="line"><span class="keyword">const</span> inc = <span class="function"><span class="params">n</span> =&gt;</span> n + <span class="number">1</span> <span class="comment">//函数体如果只有只有单行且为参数以及运算符，默认为return, 多行函数体仍需花括号包住</span></span><br><span class="line"><span class="built_in">console</span>.log(inc(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------</span></span><br><span class="line"><span class="comment">// 回调函数的优化</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment">// 使用filter过滤函数筛选奇数</span></span><br><span class="line">arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item % <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 使用箭头函数作为回调函数</span></span><br><span class="line">arr.filter(<span class="function"><span class="params">i</span> =&gt;</span> i % <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>关于<code>this</code>指向</p><blockquote><p>箭头函数不会改变this的指向</p></blockquote><ul><li><p>箭头函数内部的this指向==外部的this指向</p><blockquote><p>由于此特性产生的一系列用法</p></blockquote><ul><li>箭头函数无法通过this访问父级的参数，当然也无法直接调用</li><li>箭头函数作为子函数可以通过<code>this</code>使用爷爷辈的参数</li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">'abel'</span>,</span><br><span class="line">    <span class="comment">// 普通函数中，this指向可以帮助函数在内部访问外部函数</span></span><br><span class="line">    sayHi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`hi,my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 而在箭头函数中，this的指向未曾发生改变，就无法使用this来指向外部作用域的变量,当然也无法直接调用外部变量及方法</span></span><br><span class="line">    <span class="comment">// sayHello: () =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(`hello,my name is $&#123;name&#125;`) // ×</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="comment">// 在函数嵌套函数的情况下，可以利用闭包的原理，也可以使函数的子函数调用到函数的父函数的变量以及方法，实现隔代遗传</span></span><br><span class="line">    sayHiAsync: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 以前如何将爷爷的参数传递给孙子</span></span><br><span class="line">        <span class="comment">// const _this = this</span></span><br><span class="line">        <span class="comment">// setTimeout(function () &#123;</span></span><br><span class="line">        <span class="comment">//     console.log(_this.name)</span></span><br><span class="line">        <span class="comment">// &#125;, 1000)</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayHi()</span><br><span class="line"><span class="comment">// person.sayHello()</span></span><br><span class="line">person.sayHiAsync()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-7·对象字面量的增强"><a href="#2-7·对象字面量的增强" class="headerlink" title="2.7·对象字面量的增强"></a>2.7·对象字面量的增强</h3><blockquote><p>针对于定义对象属性及方法的改进</p></blockquote><ul><li><p>强行认儿子</p><blockquote><p>大饼卷万物，对象的属性和方法的定义也可以奉行拿来主义了。</p></blockquote><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'abel'</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name,</span><br><span class="line">    say:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>虽然不是我定义的，但是我感觉他就是我儿子`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数定义的简化</p><blockquote><p>砍掉了重复内容，function以及<code>:</code>号</p></blockquote><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'abel'</span>,</span><br><span class="line">    say () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`我不是箭头函数，我仍然可以使用对象定义的属性:<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>计算属性名</p><blockquote><p>属性名可以动态生成,关键符号 <code>[]</code></p></blockquote><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'abel'</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="comment">// name: 'abel', // 对象内部定义的不可以被计算属性名调用</span></span><br><span class="line">    name,</span><br><span class="line">    [name+<span class="string">'say'</span>]: <span class="string">'咱也不清楚最后是谁说的'</span>, <span class="comment">// 计算机属性名可以支持运算，拼接等</span></span><br><span class="line">    [name] () &#123; <span class="comment">//方法声明也可以使用计算属性名</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'方法名也可以是计算属性名'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.abelsay)</span><br><span class="line">obj.abel()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-8·对象的扩展方法"><a href="#2-8·对象的扩展方法" class="headerlink" title="2.8·对象的扩展方法"></a>2.8·对象的扩展方法</h3><blockquote><p>对于对象的固有方法的一个扩展</p></blockquote><ul><li><p>Object.assign()</p><blockquote><p>将多个源对象中的属性复制到一个目标对象中且存在覆盖行为</p><p>举个🌰：考试作弊，看一圈，没有写的我照抄，我写了的，擦了按抄过来的为准</p></blockquote><ul><li><p>语法：<code>Object.assing(&#39;目标对象&#39;,&#39;源对象&#39;)</code></p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的答案</span></span><br><span class="line"><span class="keyword">const</span> myAnswer = &#123;</span><br><span class="line">    no1: <span class="string">'A'</span>,</span><br><span class="line">    no3: <span class="string">'D'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同学A的答案</span></span><br><span class="line"><span class="keyword">const</span> myAStuderAnswer = &#123;</span><br><span class="line">    no1: <span class="string">'C'</span>,</span><br><span class="line">    no2: <span class="string">'B'</span>,</span><br><span class="line">    no3: <span class="string">'D'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同学B的答案</span></span><br><span class="line"><span class="keyword">const</span> myBStuderAnswer = &#123;</span><br><span class="line">    no1: <span class="string">'C'</span>,</span><br><span class="line">    no2: <span class="string">'E'</span>,</span><br><span class="line">    no3: <span class="string">'F'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过Object调用对象方法</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Object</span>.assign(myAnswer, myAStuderAnswer, myBStuderAnswer) <span class="comment">// 第一个参数为目标对象，第二个参数开始为源对象</span></span><br><span class="line"><span class="built_in">console</span>.log(myAnswer) <span class="comment">//返回结果：&#123; no1: 'C', no3: 'F', no2: 'E' &#125; 结论：存在覆盖且持续覆盖</span></span><br><span class="line"><span class="built_in">console</span>.log(result === myAnswer) <span class="comment">// Object.assign的返回值等于目标对象</span></span><br></pre></td></tr></table></figure></li><li><p>值得注意的地方</p><blockquote><p>Object.assign属于对象浅拷贝，拷贝过来的数据不影响源对象的内容</p></blockquote></li></ul><blockquote><p>经典的应用场景</p><p>获取对象默认值</p><p>创建个体对象的时候，将模板导入，再根据个体专属属性进行修改</p></blockquote></li><li><p>Object.is()</p><blockquote><p>判断值是否相等，关于两个值是否想等最新的概念</p></blockquote><ul><li><p>语法：<code>Object.is(值1, 值2)</code></p></li><li><p>格式示例</p><blockquote><p>罗列一些和<code>==</code> ,<code>===</code>之间判断的区别</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>)  <span class="comment">// 输出结果: false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)) <span class="comment">// 输出结果: true</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>)  <span class="comment">// 输出结果: true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>))  <span class="comment">// 输出结果: false</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>🗡议：平常判断两个值是否相等不建议使用</p></blockquote></li><li><p>Object.defineProperty()</p><blockquote><p>监视属性的读写行为</p><p>Object.defineProperty()方法会直接在一个对象上定义<strong>一个新属性</strong>，或者修改一个对象的现有属性， 并返回这个对象。如果不指定configurable, writable, enumerable ，则这些属性默认值为false，如果不指定value, get, set，则这些属性默认值为undefined</p><p>举个🌰：vue(3.0以前)的双向数据绑定就是基于该方法实现的</p></blockquote><ul><li><p>语法：<code>Object.defineProperty(obj, prop, descriptor)</code></p><ul><li>参数<ul><li>obj:需要被操作的目标对象</li><li>prop:目标对象需要定义或修改的属性的名称</li><li>descriptor:将被定义或修改的属性的描述符</li></ul></li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">'张三'</span></span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(obj.name)  <span class="comment">//张三</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Object.defineProperties()</p><blockquote><p>Object.defineProperties()方法直接在一个对象上定义<strong>一个或多个</strong>新的属性或修改现有属性，并返回该对象。</p></blockquote><ul><li><p>语法：<code>Object.defineProperties(obj, props)</code></p><ul><li>参数<ul><li>obj:需要被操作的目标对象</li><li>prop:该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置</li></ul></li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">'张三'</span>,</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        value: <span class="number">18</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj.name, obj.age) <span class="comment">// 张三, 18</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-9·Proxy（对象代理）"><a href="#2-9·Proxy（对象代理）" class="headerlink" title="2.9·Proxy（对象代理）"></a>2.9·Proxy（对象代理）</h3><blockquote><p>vue3.0开始，就开始使用Proxy来实现数据的响应</p><p>门卫，读与写等众多操作的必经之路</p></blockquote><ul><li><p>Proxy功能强大，方法众多</p><blockquote><p>常用方法如下所示</p></blockquote><ul><li><p>get</p></li><li><p>set</p></li><li><p>deleteProperty</p></li><li><p>等等…</p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="comment">// 定义一个被监视的对象</span></span><br><span class="line">    name: <span class="string">'zce'</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new 一个门卫，返回一个拥有代理的对象</span></span><br><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123; <span class="comment">// 第一个参数为被监视的对象，第二个参数为代理对象本身的内容处理</span></span><br><span class="line">    <span class="comment">// 代理里面有两大方法</span></span><br><span class="line">    <span class="comment">// get 监控数据的读取</span></span><br><span class="line">    <span class="keyword">get</span> (target, property) &#123;  <span class="comment">// get的第一个参数为监控对象本身，第二个参数为读取的属性具体是哪一个</span></span><br><span class="line">        <span class="comment">// console.log(target, property) // 通过personProxy.name调用 结果返回：&#123; name: 'zce', age: 20 &#125; name</span></span><br><span class="line">        <span class="keyword">return</span> property + <span class="string">'通过代理对象返回的值'</span> <span class="comment">// 根据查询来返回，还可以做一些修改</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// set 监控数据的改变</span></span><br><span class="line">    <span class="keyword">set</span> (target, property, value) &#123; <span class="comment">// set的前两个参数与get相同,第三个参数为修改的属性需要修改的值</span></span><br><span class="line">        <span class="keyword">if</span> (property === <span class="string">'age'</span>) &#123;</span><br><span class="line">            <span class="comment">// 可以通过限制age只能设置为Int类型</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;value&#125;</span> is not an int`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改值</span></span><br><span class="line">        target[property] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 测试数据的读取</span></span><br><span class="line"><span class="comment">// personProxy.name</span></span><br><span class="line"><span class="comment">// console.log(personProxy.name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试数据的写入</span></span><br><span class="line"><span class="built_in">console</span>.log(personProxy.age = <span class="number">22</span>)</span><br><span class="line"><span class="built_in">console</span>.log(personProxy) <span class="comment">// 修改的表面上是personProxy,但实际上是被监控的对象Person</span></span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Proxy更好的支持数组对象的监视</p><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = []</span><br><span class="line"><span class="keyword">const</span> listProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(list, &#123;</span><br><span class="line">    <span class="keyword">set</span> (target, property, value) &#123; <span class="comment">// 通过push方法调用,property会根据后一个下标位置,添加新的数组对象</span></span><br><span class="line">        <span class="comment">// console.log('set', property, value)</span></span><br><span class="line">        target[property] = value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 表示设置成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试数组的添加功能</span></span><br><span class="line">listProxy.push(<span class="number">200</span>)</span><br><span class="line"><span class="built_in">console</span>.log(list)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Proxy是以非侵入的方式监管了对象的读写</p><blockquote><p>这一个proxy的优势，再体验过Object.defineProperty()指定监视对象的属性之后才能够有所体会</p><p>是一个既有的优势</p></blockquote></li></ul><h3 id="2-10·Reflect-统一的对象操作API"><a href="#2-10·Reflect-统一的对象操作API" class="headerlink" title="2.10·Reflect 统一的对象操作API"></a>2.10·Reflect 统一的对象操作API</h3><blockquote><p>Proxy虽然牛逼，但是方法太多了，不容易掌握，Reflect提供了一套统一的操作流程</p></blockquote><ul><li><p>注意</p><ul><li>与大多数全局对象不同，Reflect不是一个构造函数。你不能将其与一个new运算符一起使用，或者将Reflect对象作为一个函数来调用</li><li>Reflect的所有属性和方法都是静态的（就像Math对象）。</li><li>Reflect内部封装了一些列对对象的底层操作的方法。 Reflect成员方法就是Proxy处理对象的默认实现</li></ul></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank" rel="noopener">Reflect</a>的十三个方法</p><blockquote><p>十三太保注定要一统对象操作的江山，所以需要好好掌握，能用这十三个方法不用之气的对象方法</p><p><code>Reflect</code>对象提供以下静态函数，它们具有与<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler" target="_blank" rel="noopener">处理器对象</a>方法相同的名称。这些方法中的一些与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener"><code>Object</code></a> 上的对应方法相同。</p></blockquote><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/apply" target="_blank" rel="noopener"><code>Reflect.apply()</code></a><ul><li>对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener"><code>Function.prototype.apply()</code></a> 功能类似。</li></ul></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/construct" target="_blank" rel="noopener"><code>Reflect.construct()</code></a><ul><li>对构造函数进行 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener"><code>new</code> </a>操作，相当于执行 <code>new target(...args)</code>。</li></ul></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/defineProperty" target="_blank" rel="noopener"><code>Reflect.defineProperty()</code></a><ul><li>和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener"><code>Object.defineProperty()</code></a> 类似。</li></ul></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty" target="_blank" rel="noopener"><code>Reflect.deleteProperty()</code></a><ul><li>作为函数的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete" target="_blank" rel="noopener"><code>delete</code></a>操作符，相当于执行 <code>delete target[name]</code>。</li></ul></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get" target="_blank" rel="noopener"><code>Reflect.get()</code></a><ul><li>获取对象身上某个属性的值，类似于 <code>target[name]。</code></li></ul></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/getOwnPropertyDescriptor" target="_blank" rel="noopener"><code>Reflect.getOwnPropertyDescriptor()</code></a><ul><li>类似于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" rel="noopener"><code>Object.getOwnPropertyDescriptor()</code></a>。</li></ul></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/getPrototypeOf" target="_blank" rel="noopener"><code>Reflect.getPrototypeOf()</code></a><ul><li>类似于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="noopener"><code>Object.getPrototypeOf()</code></a>。</li></ul></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/has" target="_blank" rel="noopener"><code>Reflect.has()</code></a><ul><li>判断一个对象是否存在某个属性，和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in" target="_blank" rel="noopener"><code>in</code> 运算符</a> 的功能完全相同。</li></ul></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/isExtensible" target="_blank" rel="noopener"><code>Reflect.isExtensible()</code></a><ul><li>类似于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible" target="_blank" rel="noopener"><code>Object.isExtensible()</code></a>.</li></ul></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys" target="_blank" rel="noopener"><code>Reflect.ownKeys()</code></a><ul><li>返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="noopener"><code>Object.keys()</code></a>, 但不会受<code>enumerable影响</code>).</li></ul></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/preventExtensions" target="_blank" rel="noopener"><code>Reflect.preventExtensions()</code></a><ul><li>类似于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions" target="_blank" rel="noopener"><code>Object.preventExtensions()</code></a>。返回一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Boolean" target="_blank" rel="noopener"><code>Boolean</code></a>。</li></ul></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/set" target="_blank" rel="noopener"><code>Reflect.set()</code></a><ul><li>值分配给属性的函数。返回一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Boolean" target="_blank" rel="noopener"><code>Boolean</code></a>，如果更新成功，则返回<code>true</code>。</li></ul></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/setPrototypeOf" target="_blank" rel="noopener"><code>Reflect.setPrototypeOf()</code></a><ul><li>类似于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener"><code>Object.setPrototypeOf()</code></a>。</li></ul></li></ul></li><li><p>格式示例</p><blockquote><p>十三个方法的初体验</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -------------------------------------------</span></span><br><span class="line"><span class="comment">// 十三个方法的初体验</span></span><br><span class="line"><span class="comment">// -------------------------------------------------</span></span><br><span class="line"><span class="comment">// 对象声明</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'abel'</span>,</span><br><span class="line">    sex: <span class="string">'男'</span>,</span><br><span class="line">    age: <span class="number">23</span>,</span><br><span class="line">    job: <span class="string">'coder'</span>,</span><br><span class="line">    say () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 定义一个getter访问器</span></span><br><span class="line">    <span class="keyword">get</span> did() &#123; <span class="keyword">return</span> <span class="string">`Abel 喜欢 <span class="subst">$&#123;<span class="keyword">this</span>._did&#125;</span>`</span>; &#125;,</span><br><span class="line">    <span class="comment">// 定义一个setter访问器</span></span><br><span class="line">    <span class="keyword">set</span> Old(val) &#123; old = val + <span class="keyword">this</span>.age; &#125;,</span><br><span class="line">    <span class="keyword">get</span> Old() &#123; <span class="keyword">return</span> old&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------</span></span><br><span class="line"><span class="comment">/* Reflect.apply() </span></span><br><span class="line"><span class="comment">说明: 通过指定的参数列表发起对目标(target)函数的调用,改变this指向调用函数</span></span><br><span class="line"><span class="comment">语法: Reflect.apply(target, thisArgument, argumentsList)</span></span><br><span class="line"><span class="comment">参数说明:  </span></span><br><span class="line"><span class="comment">    target</span></span><br><span class="line"><span class="comment">         目标函数。</span></span><br><span class="line"><span class="comment">    thisArgument</span></span><br><span class="line"><span class="comment">         target函数调用时绑定的this对象。</span></span><br><span class="line"><span class="comment">    argumentsList</span></span><br><span class="line"><span class="comment">         target函数调用时传入的实参列表，该参数应该是一个类数组的对象。*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">myname</span>) </span>&#123; <span class="comment">// 唯一的形参是apply方法的第三个参数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'关键词`apply`: 改变了this执行,还可以传参,'</span> + myname + <span class="string">"的性别是"</span> + <span class="keyword">this</span>.sex); <span class="comment">// 通过apply改变了this的指向,将this指向了第二个参数obj</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Reflect</span>.apply(func, obj,[<span class="string">"Abel"</span>]) <span class="comment">// 返回的结果为: Abel的性别是男</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reflect.construct()</span></span><br><span class="line"><span class="comment">说明: 该方法的作用和 new Date() 创建一个实列方法作用类似，那么使用该方法，我们就可以提供一种不使用new来调用构造函数的方法</span></span><br><span class="line"><span class="comment">语法: Reflect.construct(target, argumentsList[, newTarget])</span></span><br><span class="line"><span class="comment">参数说明: </span></span><br><span class="line"><span class="comment">    target</span></span><br><span class="line"><span class="comment">         被运行的目标构造函数</span></span><br><span class="line"><span class="comment">    argumentsList</span></span><br><span class="line"><span class="comment">         类数组，目标构造函数调用时的参数。</span></span><br><span class="line"><span class="comment">    newTarget 可选</span></span><br><span class="line"><span class="comment">         新创建对象的原型对象， 参考 new.target 操作符，默认值为target。 */</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="built_in">Reflect</span>.construct(<span class="built_in">Date</span>, [<span class="number">2020</span>, <span class="number">5</span>, <span class="number">15</span>]); <span class="comment">// 当只有两个参数的时候,第三个参数,新创建参数的原型对象就是目标对象,目标函数(因此最好第一个参数就是构造函数就好了嘛)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'关键词`construct`: 实例化了一个Date对象,它可以调用构造函数Date的方法,今年是: '</span> + date.getFullYear()); <span class="comment">// 实例化出来的对象,可以调用构造函数的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------</span></span><br><span class="line"><span class="comment">/* Reflect.defineProperty()</span></span><br><span class="line"><span class="comment">说明: 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回一个布尔值</span></span><br><span class="line"><span class="comment">语法: Reflect.defineProperty(target, propertyKey, attributes)</span></span><br><span class="line"><span class="comment">参数说明:</span></span><br><span class="line"><span class="comment">    target</span></span><br><span class="line"><span class="comment">        目标对象。</span></span><br><span class="line"><span class="comment">    propertyKey</span></span><br><span class="line"><span class="comment">        要定义或修改的属性的名称。</span></span><br><span class="line"><span class="comment">    attributes</span></span><br><span class="line"><span class="comment">        要定义或修改的属性的描述。 */</span></span><br><span class="line"><span class="keyword">const</span> result_define = <span class="built_in">Reflect</span>.defineProperty(obj, <span class="string">'sex'</span>, &#123;<span class="attr">value</span>: <span class="string">'女'</span>&#125;) <span class="comment">// 第二个参数,属性名应为字符串格式,第三个参数,对象中的value,为对应的修改值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'关键词`defineProperty`: 修改obj的sex为女,结果为: '</span> + result_define)</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------</span></span><br><span class="line"><span class="comment">/* Reflect.deleteProperty()</span></span><br><span class="line"><span class="comment">说明: 用于删除属性,并返回一个布尔值</span></span><br><span class="line"><span class="comment">语法: Reflect.deleteProperty(target, propertyKey)</span></span><br><span class="line"><span class="comment">参数说明: </span></span><br><span class="line"><span class="comment">    target</span></span><br><span class="line"><span class="comment">         删除属性的目标对象。</span></span><br><span class="line"><span class="comment">    propertyKey</span></span><br><span class="line"><span class="comment">         需要删除的属性的名称。 */</span></span><br><span class="line"><span class="keyword">const</span> result_delect = <span class="built_in">Reflect</span>.deleteProperty(obj, <span class="string">'job'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'关键词`delectProperty`: 删除了obj的job属性,结果为: '</span> + result_delect)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------</span></span><br><span class="line"><span class="comment">/* Reflect.get()</span></span><br><span class="line"><span class="comment">说明: 读取属性,并返回属性值</span></span><br><span class="line"><span class="comment">语法: Reflect.get(target, propertyKey[, receiver])did</span></span><br><span class="line"><span class="comment">参数说明:</span></span><br><span class="line"><span class="comment">    target</span></span><br><span class="line"><span class="comment">         需要取值的目标对象</span></span><br><span class="line"><span class="comment">    propertyKey</span></span><br><span class="line"><span class="comment">         需要获取的值的键值</span></span><br><span class="line"><span class="comment">    receiver</span></span><br><span class="line"><span class="comment">         如果target对象中指定了getter，receiver则为getter调用时的this值。 */</span></span><br><span class="line"><span class="keyword">const</span> result_get = <span class="built_in">Reflect</span>.get(obj, <span class="string">'did'</span>, &#123; <span class="attr">_did</span>: <span class="string">'打豆豆'</span> &#125;) <span class="comment">// 如果第二个参数指向是一个getter访问器，此访问器的this是指向第三个参数的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'关键词`get`: 获取了abel的喜好,是通过第三个参数传进去的: '</span> + result_get)</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------</span></span><br><span class="line"><span class="comment">/* Reflect.getOwnPropertyDescriptor()</span></span><br><span class="line"><span class="comment">说明: 获取属性的详细描述,返回属性的描述符</span></span><br><span class="line"><span class="comment">语法: Reflect.getOwnPropertyDescriptor(target, propertyKey)</span></span><br><span class="line"><span class="comment">参数说明:</span></span><br><span class="line"><span class="comment">    target</span></span><br><span class="line"><span class="comment">        需要寻找属性的目标对象。</span></span><br><span class="line"><span class="comment">    propertyKey</span></span><br><span class="line"><span class="comment">        获取自己的属性描述符的属性的名称。 */</span></span><br><span class="line"><span class="keyword">const</span> result_getDescriptor = <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(obj, <span class="string">'name'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'关键词`getOwnPropertyDescriptor`: 可以准确的获取一个属性的描述符: '</span> + result_getDescriptor)</span><br><span class="line"><span class="comment">// console.log(result_getDescriptor)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------</span></span><br><span class="line"><span class="comment">/* Reflect.getPrototypeOf()</span></span><br><span class="line"><span class="comment">说明: 返回指定对象的原型 (即内部的 [[Prototype]] 属性的值)</span></span><br><span class="line"><span class="comment">语法: Reflect.getPrototypeOf(target)</span></span><br><span class="line"><span class="comment">参数说明:</span></span><br><span class="line"><span class="comment">    target</span></span><br><span class="line"><span class="comment">        获取原型的目标对象。 */</span></span><br><span class="line"><span class="keyword">const</span> result_getPrototy = <span class="built_in">Reflect</span>.getPrototypeOf(obj)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'关键词`getPrototypeOf`: 可以获取示例对象的原型,例如实例对象obj的原型为: '</span> + result_getPrototy)</span><br><span class="line"><span class="comment">// console.log(result_getPrototy)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------</span></span><br><span class="line"><span class="comment">/* Reflect.has()</span></span><br><span class="line"><span class="comment">说明: 用于检查一个对象是否拥有某个属性,返回一个布尔值</span></span><br><span class="line"><span class="comment">语法: Reflect.has(target, propertyKey)</span></span><br><span class="line"><span class="comment">参数说明:</span></span><br><span class="line"><span class="comment">    target</span></span><br><span class="line"><span class="comment">        目标对象.</span></span><br><span class="line"><span class="comment">    propertyKey</span></span><br><span class="line"><span class="comment">        属性名，需要检查目标对象是否存在此属性。 */</span></span><br><span class="line"><span class="keyword">const</span> result_has = <span class="built_in">Reflect</span>.has(obj, <span class="string">'name'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'关键词`has`: 可以查目标对象是否存在此属性,例如实例对象obj中有name属性: '</span> + result_has)</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------</span></span><br><span class="line"><span class="comment">/* Reflect.isExtensible()</span></span><br><span class="line"><span class="comment">说明: 判断一个对象是否可扩展 （即是否能够添加新的属性）</span></span><br><span class="line"><span class="comment">语法: Reflect.isExtensible(target)</span></span><br><span class="line"><span class="comment">参数说明:</span></span><br><span class="line"><span class="comment">    target</span></span><br><span class="line"><span class="comment">        检查是否可扩展的目标对象。 */</span></span><br><span class="line"><span class="keyword">const</span> result_Extensible = <span class="built_in">Reflect</span>.isExtensible(obj)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'关键词`isExtensible`: 可以查目标对象是否可以扩展,例如对象obj可以扩展: '</span> + result_Extensible)</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------</span></span><br><span class="line"><span class="comment">/* Reflect.ownKeys()</span></span><br><span class="line"><span class="comment">说明: 返回一个由目标对象自身的属性键组成的数组。</span></span><br><span class="line"><span class="comment">语法: Reflect.ownKeys(target)</span></span><br><span class="line"><span class="comment">参数说明:</span></span><br><span class="line"><span class="comment">    target</span></span><br><span class="line"><span class="comment">        获取自身属性键的目标对象。 */</span></span><br><span class="line"><span class="keyword">const</span> result_Ownkeys = <span class="built_in">Reflect</span>.ownKeys(obj)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'关键词`ownKeys`: 获取自身属性键的目标对象,例如对象obj的自身属性键组成的数组为: '</span> + result_Ownkeys)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------</span></span><br><span class="line"><span class="comment">/* Reflect.preventExtensions()</span></span><br><span class="line"><span class="comment">说明: 阻止新属性添加到对象 (例如：防止将来对对象的扩展被添加到对象中)。返回一个布尔值</span></span><br><span class="line"><span class="comment">语法: Reflect.preventExtensions(target)</span></span><br><span class="line"><span class="comment">参数说明:</span></span><br><span class="line"><span class="comment">    target</span></span><br><span class="line"><span class="comment">        阻止扩展的目标对象 */</span></span><br><span class="line"><span class="keyword">const</span> result_noExtensible = <span class="built_in">Reflect</span>.preventExtensions(obj)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'关键词`preventExtensions`: 可以设置对象不可以扩展,例如对象obj将不再可以扩展: '</span> + result_noExtensible)</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------</span></span><br><span class="line"><span class="comment">/* Reflect.set()</span></span><br><span class="line"><span class="comment">说明: 设置一个属性,返回布尔值</span></span><br><span class="line"><span class="comment">语法: Reflect.set(target, propertyKey, value[, receiver])</span></span><br><span class="line"><span class="comment">参数说明:</span></span><br><span class="line"><span class="comment">    target</span></span><br><span class="line"><span class="comment">        设置属性的目标对象。</span></span><br><span class="line"><span class="comment">    propertyKey</span></span><br><span class="line"><span class="comment">        设置的属性的名称。</span></span><br><span class="line"><span class="comment">    value</span></span><br><span class="line"><span class="comment">        设置的值。</span></span><br><span class="line"><span class="comment">    receiver</span></span><br><span class="line"><span class="comment">        如果遇到 setter，receiver则为setter调用时的this值。 */</span></span><br><span class="line"><span class="keyword">const</span> result_set = <span class="built_in">Reflect</span>.set(obj, <span class="string">'Old'</span>, <span class="number">5</span> , &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;) <span class="comment">//如果是一个setter访问器，此访问器的this是指向第四个参数的。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'关键词`set`: 可以设置对象的设置一个属性: '</span> + result_set + <span class="string">',通过setter修改的值为:'</span> + <span class="built_in">Reflect</span>.get(obj, <span class="string">'Old'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="comment">/* Reflect.setPrototypeOf()</span></span><br><span class="line"><span class="comment">说明: 设置对象的原型（即内部的 [[Prototype]] 属性）为另一个对象或 null,返回 一个布尔值</span></span><br><span class="line"><span class="comment">语法: Reflect.setPrototypeOf(target, prototype)</span></span><br><span class="line"><span class="comment">参数说明:</span></span><br><span class="line"><span class="comment">    target</span></span><br><span class="line"><span class="comment">        设置原型的目标对象。</span></span><br><span class="line"><span class="comment">    prototype</span></span><br><span class="line"><span class="comment">        对象的新原型（一个对象或 null）。  */</span></span><br><span class="line"><span class="keyword">const</span> result_setPrototype = <span class="built_in">Reflect</span>.setPrototypeOf(obj, <span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'关键词`setPrototypeOf`: 可以设置对象的原型为一个对象或 null: '</span> + result_setPrototype)</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-11·Promise-一套更优的异步解决方案"><a href="#2-11·Promise-一套更优的异步解决方案" class="headerlink" title="2.11·Promise 一套更优的异步解决方案"></a>2.11·Promise 一套更优的异步解决方案</h3><blockquote><p>本节内容，单拎出来</p></blockquote><h3 id="2-12·class类"><a href="#2-12·class类" class="headerlink" title="2.12·class类"></a>2.12·class类</h3><blockquote><p>老牌的面向对象语言都有的class类</p></blockquote><ul><li><p>定义class类</p><ul><li><p>实例方法vs静态方法</p><ul><li>实例方法：通过类构造出来的实例对象去调用</li><li>静态方法<code>static</code>：直接通过类本身去调用<ul><li>以前通过在构造函数对象上挂载方法来实现</li></ul></li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造器里面放属性</span></span><br><span class="line">    <span class="keyword">constructor</span> (name, sex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.sex = sex</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义方法</span></span><br><span class="line">    say () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`hi,my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> i am a <span class="subst">$&#123;<span class="keyword">this</span>.sex&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ES2015中新增添加静态成员的static关键词</span></span><br><span class="line">    <span class="keyword">static</span> create (name, sex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name, sex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">const</span> abel = <span class="keyword">new</span> Person(<span class="string">'abel'</span>,<span class="string">'man'</span>)</span><br><span class="line">abel.say()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过静态方法实例对象</span></span><br><span class="line"><span class="keyword">const</span> tom = Person.create(<span class="string">'tom'</span>, <span class="string">'man'</span>)</span><br><span class="line">tom.say()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>继承</p><blockquote><p>以前通过原型的方式来实现继承,真得是挺乱的</p></blockquote><ul><li><p>通过extends来继承父类</p></li><li><p>通过super方法来访问父类成员</p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (name, age) &#123;</span><br><span class="line">        <span class="comment">// 使用super访问父类</span></span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    hello () &#123;</span><br><span class="line">        <span class="keyword">super</span>.say() <span class="comment">// 但是字类为访问的无法获取 hi,my name is doinb i am a undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`age: <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> create (name, age) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(name, age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> doinb = Student.create(<span class="string">'doinb'</span>, <span class="string">'23'</span>)</span><br><span class="line">doinb.hello()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-13·Set-数据结构"><a href="#2-13·Set-数据结构" class="headerlink" title="2.13·Set 数据结构"></a>2.13·Set 数据结构</h3><blockquote><p>类似一个数组，但是不允许数组成员重复</p></blockquote><ul><li><p>set 数据结构常用方法</p><ul><li>set.add(value)<ul><li>添加一个值，返回set结构本身</li></ul></li><li>set.delete(value)<ul><li>删除指定数据，返回布尔值</li></ul></li><li>set.has(value)<ul><li>判断该值是否存在，返回布尔值</li></ul></li><li>set.clear()<ul><li>清除所有数据，没有返回值</li></ul></li><li>set.keys()<ul><li>返回键名遍历器</li></ul></li><li>set.entries()<ul><li>返回键值对遍历器</li></ul></li><li>循环遍历：forEach/for of</li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似于数组，但是组内成员不允许重复</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用方法：</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    set.add(value) 添加一个值，返回set结构本身</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">3</span>).add(<span class="number">4</span>).add(<span class="number">1</span>) <span class="comment">// 重复的值将被忽略</span></span><br><span class="line"><span class="built_in">console</span>.log(s) <span class="comment">// 输出结果： Set(4) &#123; 1, 2, 3, 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    set.delete(value) 删除指定数据，返回布尔值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(s.delete(<span class="number">1</span>)) <span class="comment">// 输出结果：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    set.has(value) 判断该值是否存在，返回布尔值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(s.has(<span class="number">2</span>)) <span class="comment">// 输出结果：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    set.clear() 清除所有数据，没有返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// s.clear()</span></span><br><span class="line"><span class="built_in">console</span>.log(s) <span class="comment">// 如果执行的话，输出结果： Set(0) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    set.keys() 返回键名遍历器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(s.keys()) <span class="comment">// 输出结果：[Set Iterator] &#123; 2, 3, 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    set.entries() 返回键值对遍历器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(s.entries()) <span class="comment">// 输出结果：[Set Entries] &#123; [ 2, 2 ], [ 3, 3 ], [ 4, 4 ] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    循环遍历：forEach/for of</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123; <span class="built_in">console</span>.log(i) &#125; <span class="comment">// 输出结果：2 3 4</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>经典的应用场景</p><p>普通数组去重</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [...new <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])]</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// 输出结果： [ 1, 2, 3, 4, 5, 6 ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="2-14·Map-数据结构"><a href="#2-14·Map-数据结构" class="headerlink" title="2.14·Map 数据结构"></a>2.14·Map 数据结构</h3><blockquote><p>类似于对象</p><p>都是键值对的集合</p><p>对键的范围的升级，<strong>允许使用其他类型</strong>，例如：对象，数组，布尔类型（对象的键只能是字符串，如果不是也会转换为字符串）</p></blockquote><ul><li><p>map数据结构常用方法</p><ul><li>map.set(key,value)<ul><li>设置键名key对应的键值为value，然后返回map。</li></ul></li><li>map.get(key)<ul><li>根据键名，获取并返回对应的值</li></ul></li><li>map.has(key)<ul><li>判断某个键是否再当前的map对象中，返回一个布尔类型</li></ul></li><li>map.delete(key)<ul><li>删除某个键，返回一个布尔值</li></ul></li><li>map.clear()<ul><li>清空Map对象 无返回值</li></ul></li><li>map.keys()<ul><li>返回键名的遍历器</li></ul></li><li>map.values()<ul><li>返回键值的遍历器</li></ul></li><li>map.entries()<ul><li>返回所有成员的遍历器</li></ul></li><li>循环遍历<ul><li>map.forEach()/for of</li></ul></li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'abel'</span>,</span><br><span class="line">    age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">// 常用方法</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    map.set(key,value) 设置键名key对应的键值为value，然后返回map。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m.set(obj, <span class="string">'是一个人'</span>)) <span class="comment">// 输出结果：Map(1) &#123; &#123; name: 'abel', age: 23 &#125; =&gt; '是一个人' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    map.get(key) 根据键名，获取并返回对应的值</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="built_in">console</span>.log(m.get(obj)) <span class="comment">// 输出结果：是一个人</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    map.has(key) 判断某个键是否再当前的map对象中，返回一个布尔类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(m.has(obj)) <span class="comment">// 输出结果：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    map.delete(key) 删除某个键，返回一个布尔值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(m.delete(obj)) <span class="comment">// 输出结果：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    map.clear() 清空Map对象 无返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(m.clear()) <span class="comment">// 输出结果：undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">// 为了更好的展示遍历结果，添加几个键值对</span></span><br><span class="line">m.set(obj, <span class="string">'是一个对象'</span>)</span><br><span class="line">m.set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="string">'是一个数组'</span>)</span><br><span class="line">m.set(<span class="string">'abel'</span>, <span class="string">'是一个字符串'</span>)</span><br><span class="line">m.set(<span class="literal">true</span>, <span class="string">'是一个布尔类型'</span>)</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    map.keys() 返回键名的遍历器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(m.keys()) <span class="comment">// 输出结果：[Map Iterator] &#123; &#123; name: 'abel', age: 23 &#125;, [ 1, 2, 3 ], 'abel', true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    map.values() 返回键值的遍历器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(m.values()) <span class="comment">// 输出结果：[Map Iterator] &#123; '是一个对象', '是一个数组', '是一个字符串', '是一个布尔类型' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    map.entries() 返回所有成员的遍历器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(m.entries()) </span><br><span class="line"><span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">    [Map Entries] &#123;</span></span><br><span class="line"><span class="comment">        [ &#123; name: 'abel', age: 23 &#125;, '是一个对象' ],</span></span><br><span class="line"><span class="comment">        [ [ 1, 2, 3 ], '是一个数组' ],</span></span><br><span class="line"><span class="comment">        [ 'abel', '是一个字符串' ],</span></span><br><span class="line"><span class="comment">        [ true, '是一个布尔类型' ]</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    map.forEach() 遍历数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">m.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">    &#123; name: 'abel', age: 23 &#125; 是一个对象</span></span><br><span class="line"><span class="comment">    [ 1, 2, 3 ] 是一个数组</span></span><br><span class="line"><span class="comment">    abel 是一个字符串</span></span><br><span class="line"><span class="comment">    true 是一个布尔类型 */</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-15·Symbol-一种全新的原始数据类型"><a href="#2-15·Symbol-一种全新的原始数据类型" class="headerlink" title="2.15·Symbol 一种全新的原始数据类型"></a>2.15·Symbol 一种全新的原始数据类型</h3><blockquote><p>symbol翻译过来就是 符号，它表示一个独一无二的值</p><p>​    目前存在的数据类型：</p><p>​        基本类型：String、Number、Boolean、Symbol、Undefined、Null (正在标准化的类型：BigInt)</p><p>​        引用类型：Object(object,array,function)</p></blockquote><ul><li><p>特点</p><ul><li>全新的数据类型</li><li>独一无二，自己都不等于自己</li><li>括号内的是描述，区分不同的Symbol</li></ul></li><li><p>可以作为对象的属性名(作为私有属性绝佳)</p><ul><li><p>通过<code>for</code>方法来复用属性（属性值为字符串）</p></li><li><p>唯一的获取方法<code>Object.getOwnPropertySymbols(对象名)</code></p></li><li><p>内置常量</p><blockquote><p>用来实现js内部接口</p></blockquote><ul><li>Symbol.iterator</li><li>Symbol.hasInstance</li><li>Symbol.toStringTag</li></ul></li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    全新的数据类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s) <span class="comment">// 输出结果: symbol</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    独一无二</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> y = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="built_in">console</span>.log(s === y) <span class="comment">// 输出结果: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    括号里面填的是描述</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>(<span class="string">'abel'</span>)) <span class="comment">// 输出结果: Symbol(abel) // 和字符串一样的颜色绿色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    作为属性名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">obj[<span class="built_in">Symbol</span>(<span class="string">'name'</span>)] = <span class="string">'abel'</span></span><br><span class="line">obj[<span class="built_in">Symbol</span>(<span class="string">'sex'</span>)] = <span class="string">'man'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// 输出结果: &#123; [Symbol(name)]: 'abel', [Symbol(sex)]: 'man' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    for复用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2) <span class="comment">// 输出结果: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Object.getOwnPropertySymbols(对象名) 获取对象中是symbol类型的属性名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj)) <span class="comment">// 输出结果: [ Symbol(name), Symbol(sex) ]</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>经典的应用场景</p><p>为对象添加一个独一无二的属性名作为私有属性</p><p>毕竟它自己都不等于自己，别人也访问不到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>() === <span class="built_in">Symbol</span>()) <span class="comment">// 输出结果: false</span></span><br><span class="line"><span class="comment">// a为私有属性</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line"> a: <span class="string">'abc'</span>,</span><br><span class="line"> say () &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.say() <span class="comment">// 输出结果：abc</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="2-16·Iterable-可迭代接口"><a href="#2-16·Iterable-可迭代接口" class="headerlink" title="2.16·Iterable 可迭代接口"></a>2.16·Iterable 可迭代接口</h3><blockquote><p>ES中能够表示有结构的数据类型越来越多</p><p>​        例如: object,array,set,map,自定义组合使用</p><p>​    为了给各种各样的数据结构提供统一的遍历方式</p><p>​        就要统一遍历接口</p><p>​    实现iterable接口就是for…of的前提</p></blockquote><ul><li><p>iterable实现原理的分析</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    内部已经实现iterable的三种数据结构</span></span><br><span class="line"><span class="comment">        array,set,map</span></span><br><span class="line"><span class="comment">    控制台输入:</span></span><br><span class="line"><span class="comment">        console.log([])</span></span><br><span class="line"><span class="comment">        console.log(new Set())</span></span><br><span class="line"><span class="comment">        console.log(new Map())</span></span><br><span class="line"><span class="comment">    都可以在原型上面找到</span></span><br><span class="line"><span class="comment">        Symbol(Symbol.iterator) 方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    查看iterator方法的内容的实现</span></span><br><span class="line"><span class="comment">    控制台输入:</span></span><br><span class="line"><span class="comment">        const arr = ['a', 'b', 'c']</span></span><br><span class="line"><span class="comment">        arr[Symbol.iterator]() </span></span><br><span class="line"><span class="comment">    控制台返回:</span></span><br><span class="line"><span class="comment">        Array Iterator &#123;&#125;</span></span><br><span class="line"><span class="comment">            =&gt; next() // 确认目标</span></span><br><span class="line"><span class="comment">    控制台输入:</span></span><br><span class="line"><span class="comment">        const iterator = arr[Symbol.iterator]()</span></span><br><span class="line"><span class="comment">        iterator.next()</span></span><br><span class="line"><span class="comment">    控制台返回:</span></span><br><span class="line"><span class="comment">        &#123; value: "a", done: false &#125; // 可以观察到第一个属性就是我们定义的arr的值</span></span><br><span class="line"><span class="comment">    控制台输入:</span></span><br><span class="line"><span class="comment">        iterator.next() // 持续输入,内部维护的指针将把数组中的内容依次返回</span></span><br><span class="line"><span class="comment">        最后: &#123; value: undefined, done: true &#125; // done表示着内部数据是否为空</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    总结: //也是for...of循环的工作原理</span></span><br><span class="line"><span class="comment">        所有可以直接被for...of循环遍历的数据类型,都实现了iterator的接口.</span></span><br><span class="line"><span class="comment">        该数据结构类型内部必定挂载了iterator方法</span></span><br><span class="line"><span class="comment">        iterator方法返回了一个带有next()方法的对象</span></span><br><span class="line"><span class="comment">        通过持续的反复调用next()方法,直到done为true,就可以完成完整的遍历一遍了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>实现可迭代接口</p><blockquote><p>处理没有默认实现iterable的数据结构类型,让for-of能够真正的做到遍历所有的数据结构类型</p></blockquote><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三层接口,实现迭代器</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; </span><br><span class="line">    <span class="comment">// 定义一个用于迭代的数组</span></span><br><span class="line">    store: [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>],</span><br><span class="line">    <span class="comment">// 第一层,iterable,实现可迭代接口,规定内部必须有一个用于返回迭代器的方法,iterator</span></span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">        <span class="comment">// 第二层,iterator,实现迭代器接口,规定内部必须有一个用于迭代的next()方法</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> result = &#123;</span><br><span class="line">                    value: self.store[index],</span><br><span class="line">                    done: index &gt;= self.store.length</span><br><span class="line">                &#125;</span><br><span class="line">                index++</span><br><span class="line">                <span class="comment">// 第三层,iterationResult,迭代结果接口,规定必须有一个value属性,用来表示当前被迭代到的数据,一个done属性,用来表示迭代有没有结束</span></span><br><span class="line">                <span class="keyword">return</span> result </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'循环体'</span>, item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>迭代器模式</p><blockquote><p>根据下面的示例模式，可以实现任何的数据结构的迭代</p></blockquote><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现，对外提供统一接口</span></span><br><span class="line"><span class="keyword">const</span> todos = &#123;</span><br><span class="line">    life: [<span class="string">'吃饭'</span>, <span class="string">'睡觉'</span>, <span class="string">'打豆豆'</span>],</span><br><span class="line">    learn: [<span class="string">'语文'</span>,<span class="string">'数学'</span>,<span class="string">'外语'</span>],</span><br><span class="line">    work: [<span class="string">'喝茶'</span>],    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// each方法的实现</span></span><br><span class="line">    each: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> all = [].concat(<span class="keyword">this</span>.life, <span class="keyword">this</span>.learn, <span class="keyword">this</span>.work)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> all) &#123;</span><br><span class="line">            callback(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterator方法的实现</span></span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> all = [...this.life, ...this.learn, ...this.work]</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    value: all[index],</span><br><span class="line">                    done: index++ &gt;= all.length</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'---------------------------------------'</span>)</span><br><span class="line"></span><br><span class="line">todos.each(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)   </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'---------------------------------------'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> todos) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-17·for-of-循环"><a href="#2-17·for-of-循环" class="headerlink" title="2.17·for-of 循环"></a>2.17·for-of 循环</h3><blockquote><p>全新的遍历方式</p><p>可以作为今后遍历所有数据结构的统一方式(前提是都通过iterable进行接口处理)</p></blockquote><ul><li><p>特点</p><ul><li>break 关键词可以随时终止遍历</li></ul></li><li><p>默认已经经过iterable，可以直接使用for…of</p><ul><li>数组</li><li>set</li><li>map</li></ul></li><li><p>遍历数组</p><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    遍历Array</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// break 关键词可以随时终止遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(item) <span class="comment">// 返回的是值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    遍历Map</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 此处为练习使用map数据结构</span></span><br><span class="line"><span class="keyword">const</span> arrD = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">arrD.set(&#123; <span class="attr">name</span>: <span class="number">123</span> &#125;, <span class="string">'456'</span>)</span><br><span class="line">arrD.set( <span class="string">'abc'</span>, <span class="string">'deg'</span> )</span><br><span class="line">arrD.set( <span class="literal">true</span>, <span class="string">'ok'</span> )</span><br><span class="line">arrD.set( [<span class="string">'a'</span>, <span class="string">'b'</span>], [<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>] )</span><br><span class="line"><span class="comment">// console.log(arrD)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> arrD) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`键来:<span class="subst">$&#123; key &#125;</span>,值来: <span class="subst">$&#123; value &#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    遍历Set</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">3</span>).add(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-18·Generator-生成器"><a href="#2-18·Generator-生成器" class="headerlink" title="2.18·Generator 生成器"></a>2.18·Generator 生成器</h3><blockquote><p>一种函数</p><p>为了避免异步编程中回调嵌套过深而诞生，提供更好的异步编程解决方案</p></blockquote><ul><li><p>普通函数，函数名前面加<code>*</code>即可形成最基础的生成器函数</p></li><li><p>关键词</p><ul><li>yield</li></ul></li><li><p>应用场景</p><ul><li>发号器</li><li>使用Generator函数实现iterator方法</li></ul></li><li><p>关于回调函数嵌套过深的问题，放在异步编程中详细描述</p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -------------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    定义一个生成器函数</span></span><br><span class="line"><span class="comment">        函数名前面加星号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'函数体开始执行了'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = foo()</span><br><span class="line"><span class="built_in">console</span>.log(result) </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">node环境输出结果：</span></span><br><span class="line"><span class="comment">    Object [Generator] &#123;&#125; // 生成器对象</span></span><br><span class="line"><span class="comment">chrome环境输出结果：</span></span><br><span class="line"><span class="comment">    foo &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="comment">    __proto__: Generator</span></span><br><span class="line"><span class="comment">    __proto__: Generator</span></span><br><span class="line"><span class="comment">    constructor: GeneratorFunction &#123;prototype: Generator, Symbol(Symbol.toStringTag): "GeneratorFunction", constructor: ƒ&#125;</span></span><br><span class="line"><span class="comment">    next: ƒ next()  // 发现亮点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 试着进一步打印next()方法的执行结果</span></span><br><span class="line"><span class="built_in">console</span>.log(result.next()) <span class="comment">// 输出结果：函数体开始执行了 &#123; value: 100, done: true &#125; // 发现亮点，拥有和迭代器next()方法的返回值相同的结构 函数中的返回值被放入value中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    以上内容得出结论：</span></span><br><span class="line"><span class="comment">        生成器对象也实现了迭代器的协议</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    生成器的基本作用</span></span><br><span class="line"><span class="comment">        关键词：</span></span><br><span class="line"><span class="comment">            yield: </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第一次执行'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第二次执行'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第三次执行'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = foo()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// 输出结果：第一次执行 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// 输出结果：第二次执行 &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// 输出结果：第三次执行 &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// 输出结果：第四次执行 &#123; value: 4, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    分析：</span></span><br><span class="line"><span class="comment">        生成器的基本使用</span></span><br><span class="line"><span class="comment">        通过 * 将普通对象编程了生成器,通过调用生成器产生一个生成器对象</span></span><br><span class="line"><span class="comment">        生成器对象只能通过调用next()方法才能开始执行</span></span><br><span class="line"><span class="comment">        每使用next()方法，执行到yield关键词就会暂停下来</span></span><br><span class="line"><span class="comment">        yield后面的值，将会作为next的value结果返回</span></span><br><span class="line"><span class="comment">        且生成器对象只能惰性执行next()方法，因此需要多次执行next()方法才能执行完所有代码，next返回的done则变为true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    生成器的应用场景</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    案例一：发号器</span></span><br><span class="line"><span class="comment">        通过单击按钮，获取一个递增的返回结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">createIdMaker</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> id = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> id++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> idMaker = createIdMaker() <span class="comment">// 创建一个发号器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(idMaker.next().value) <span class="comment">// 输出结果：1</span></span><br><span class="line"><span class="built_in">console</span>.log(idMaker.next().value) <span class="comment">// 输出结果：2</span></span><br><span class="line"><span class="built_in">console</span>.log(idMaker.next().value) <span class="comment">// 输出结果：3</span></span><br><span class="line"><span class="built_in">console</span>.log(idMaker.next().value) <span class="comment">// 输出结果：4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    案例二：使用Generator 函数实现 iterator 方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> todos = &#123;</span><br><span class="line">    life: [<span class="string">'吃饭'</span>, <span class="string">'睡觉'</span>, <span class="string">'打豆豆'</span>],</span><br><span class="line">    learn: [<span class="string">'语文'</span>, <span class="string">'数学'</span>, <span class="string">'外语'</span>],</span><br><span class="line">    work: [<span class="string">'喝茶'</span>],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> all = [...this.life, ...this.learn, ...this.work]</span><br><span class="line">        <span class="comment">// 因为Generator配合yield拥有和next()相同特性，因此可以使用generator来实现iterator方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> all) &#123;</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> todos) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    关于Generator的主要作用，避免异步编程中回调嵌套过深，会在JavaScript异步编程中专门介绍</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-19·ES-Modules-语言层面的模块化标准"><a href="#2-19·ES-Modules-语言层面的模块化标准" class="headerlink" title="2.19·ES Modules 语言层面的模块化标准"></a>2.19·ES Modules 语言层面的模块化标准</h3><blockquote><p>所谓语言层面，就是模块化标准的实现原理</p></blockquote><ul><li>在模块化开发部分详细描述</li></ul><h2 id="3·ES2016的学习"><a href="#3·ES2016的学习" class="headerlink" title="3·ES2016的学习"></a>3·ES2016的学习</h2><blockquote><p>小版本，只有两个小功能</p></blockquote><h3 id="3-1·-includes-包含否"><a href="#3-1·-includes-包含否" class="headerlink" title="3.1· .includes() 包含否"></a>3.1· .includes() 包含否</h3><blockquote><p>Array.prototype.includes()</p><p>轻松愉快的检测出数组是否包含指定的元素</p></blockquote><ul><li><p>与以前常用的indexOf()方法的区别</p><ul><li>返回布尔值</li><li>可以查找NaN</li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Array.prototype.includes</span></span><br><span class="line"><span class="comment">        包含否</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="string">'abc'</span>, <span class="literal">NaN</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与indexOf()的区别</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="literal">NaN</span>)) <span class="comment">// 输出结果： -1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="literal">NaN</span>)) <span class="comment">// 输出结果： true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2·-指数运算"><a href="#3-2·-指数运算" class="headerlink" title="3.2·** 指数运算"></a>3.2·<code>**</code> 指数运算</h3><ul><li><p>老牌的指数运算：Math.pow()</p></li><li><p>格式：<code>底数 ** 指数</code></p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    `**` 新的指数运算符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 老牌的指数运算，为Math中的pow方法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">3</span>)) <span class="comment">// 输出结果 8</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> ** <span class="number">3</span>) <span class="comment">// 输出结果 8</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4·ES2017的学习"><a href="#4·ES2017的学习" class="headerlink" title="4·ES2017的学习"></a>4·ES2017的学习</h2><blockquote><p>比2016大一点的小版本 主要为Object的扩展方法</p></blockquote><h3 id="4-1·Object-values"><a href="#4-1·Object-values" class="headerlink" title="4.1·Object.values"></a>4.1·Object.values</h3><blockquote><p>返回对象中所有的值组成的数组</p></blockquote><ul><li><p>语法：<code>Object.values(目标对象)</code></p></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Object.values</span></span><br><span class="line"><span class="comment">        返回对象中所有的值组成的数组</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)) <span class="comment">// 输出结果：[ 'value1', 'value2' ]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2·Object-entries"><a href="#4-2·Object-entries" class="headerlink" title="4.2·Object.entries"></a>4.2·Object.entries</h3><blockquote><p>将对象中的所有键值对通过数组的形式返回</p></blockquote><ul><li><p>语法：<code>Object.entries(目标对象)</code></p></li><li><p>常规使用</p><ul><li>返回值用于for…of循环</li><li>返回值用于转换Map数据结构</li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Object.entries</span></span><br><span class="line"><span class="comment">        将对象中的所有键值对通过数组的形式返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)) <span class="comment">// 输出结果：[ [ 'foo', 'value1' ], [ 'bar', 'value2' ] ]</span></span><br><span class="line"><span class="comment">// 案例一：</span></span><br><span class="line">    <span class="comment">// 可以使用Object.entries返回的结果，通过for...of循环遍历对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key, value)</span><br><span class="line">        <span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">            foo value1</span></span><br><span class="line"><span class="comment">            bar value2 */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 案例二：</span></span><br><span class="line">    <span class="comment">// 根据Object.entries的返回结果可以观察到，这契合了Map数据结构的要求，因此可以通过entries的返回值，将对象转换为Map数据结构</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj)))</span><br><span class="line">        <span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">            Map(2) &#123; 'foo' =&gt; 'value1', 'bar' =&gt; 'value2' &#125; */</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3·Object-getOwnPropertyDescriptors"><a href="#4-3·Object-getOwnPropertyDescriptors" class="headerlink" title="4.3·Object.getOwnPropertyDescriptors"></a>4.3·Object.getOwnPropertyDescriptors</h3><blockquote><p>获取对象的完整描述信息,完善ES2015中get，set的使用</p></blockquote><ul><li><p>语法：<code>Object.getOwnPropertyDescriptors(目标对象)</code></p></li><li><p>常规使用</p><ul><li>优化对象的复制，使git，set可以正常复制</li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Object.getOwnPropertyDescriptors</span></span><br><span class="line"><span class="comment">        获取对象的完整描述信息,完善ES2015中get，set的使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">    firstName: <span class="string">'狗蛋'</span>,</span><br><span class="line">    lastName: <span class="string">'李'</span>,</span><br><span class="line">    <span class="keyword">get</span> fullName () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Object.assing() 复制对象后，get，set存在的问题</span></span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="built_in">Object</span>.assign(&#123;&#125;, p1)</span><br><span class="line">    p2.firstName = <span class="string">'逍遥'</span> <span class="comment">// 修改p2 中的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(p2)</span><br><span class="line">    <span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">        &#123; firstName: '逍遥', lastName: '李', fullName: '狗蛋 李' &#125;</span></span><br><span class="line"><span class="comment">        结果分析:</span></span><br><span class="line"><span class="comment">            fullName通过assign复制，只是复制了值。 */</span></span><br><span class="line"><span class="comment">// 使用Object.getOwnPropertyDescriptors来解决上面的问题</span></span><br><span class="line">    <span class="keyword">const</span> descriptors = <span class="built_in">Object</span>.getOwnPropertyDescriptors(p1)</span><br><span class="line">    <span class="comment">/*  console.log(descriptors)</span></span><br><span class="line"><span class="comment">        输出结果：</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                firstName: &#123; value: '狗蛋', writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">                lastName: &#123; value: '李', writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">                fullName: &#123;</span></span><br><span class="line"><span class="comment">                    get: [Function: get fullName],</span></span><br><span class="line"><span class="comment">                    set: undefined,</span></span><br><span class="line"><span class="comment">                    enumerable: true,</span></span><br><span class="line"><span class="comment">                    configurable: true</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 通过获取对象的完整信息之后，再复制的对象，就可以完整复制set，get的使用效果</span></span><br><span class="line">    <span class="keyword">const</span> p3 = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, descriptors)</span><br><span class="line">    p3.firstName = <span class="string">'逍遥'</span></span><br><span class="line">    <span class="built_in">console</span>.log(p3.fullName) <span class="comment">// 输出内容：逍遥 李</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-4·String-prototype-padStart-String-prototype-padEnd"><a href="#4-4·String-prototype-padStart-String-prototype-padEnd" class="headerlink" title="4.4·String.prototype.padStart / String.prototype.padEnd"></a>4.4·String.prototype.padStart / String.prototype.padEnd</h3><blockquote><p>字符串填充方法，用给定的字符串去填充目标字符串的开始或结束位置</p></blockquote><ul><li><p>语法：<code>str.padStart(targetLength [, padString]) / str.padEnd(targetLength [, padString])</code></p><ul><li>参数<ul><li>targetLength ：约定的补全长度</li><li>padString：约定的补全内容</li></ul></li></ul></li><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    String.prototype.padStart / String.prototype.padEnd</span></span><br><span class="line"><span class="comment">        字符串填充方法，用给定的字符串去填充目标字符串的开始或结束位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> books = &#123;</span><br><span class="line">    html: <span class="number">5</span>,</span><br><span class="line">    css: <span class="number">16</span>,</span><br><span class="line">    javaSctipt: <span class="number">111</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [name, count] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(books)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name.padEnd(<span class="number">16</span>, <span class="string">'-'</span>)&#125;</span>=&gt;<span class="subst">$&#123;count.toString().padStart(<span class="number">3</span>, <span class="string">'0'</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出内容</span></span><br><span class="line"><span class="comment">    html------------=&gt;005</span></span><br><span class="line"><span class="comment">    css-------------=&gt;016</span></span><br><span class="line"><span class="comment">    javaSctipt------=&gt;111 */</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-5·在函数参数中添加尾逗号"><a href="#4-5·在函数参数中添加尾逗号" class="headerlink" title="4.5·在函数参数中添加尾逗号"></a>4.5·在函数参数中添加尾逗号</h3><blockquote><p>允许尾逗号的存在</p></blockquote><ul><li><p>格式示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    允许尾逗号的存在</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">]</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="keyword">const</span> abc = &#123;</span><br><span class="line">    a: <span class="string">'a'</span>,</span><br><span class="line">    b: <span class="string">'b'</span>,</span><br><span class="line">    c: <span class="string">'c'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(abc)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b,c,</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'函数的参数也有尾逗号'</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-6·Async-Await"><a href="#4-6·Async-Await" class="headerlink" title="4.6·Async / Await"></a>4.6·Async / Await</h3><blockquote><p>小版本中的重量级更新部分，用于异步处理的进一步优化</p><p>彻底解决异步回调函数嵌套过深的问题</p><p>本质：promise的语法糖</p></blockquote><ul><li>在异步函数模块详细描述</li></ul>]]></content>
      
      
      <categories>
          
          <category> 拉钩大前端学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序基础部分的学习笔记</title>
      <link href="/2020/05/12/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/12/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://developers.weixin.qq.com/doc/" target="_blank" rel="noopener">微信官方文档</a></li></ul><h3 id="小程序基础知识初探"><a href="#小程序基础知识初探" class="headerlink" title="小程序基础知识初探"></a>小程序基础知识初探</h3><h3 id="1-小程序的原生框架"><a href="#1-小程序的原生框架" class="headerlink" title="1 小程序的原生框架"></a>1 小程序的原生框架</h3><blockquote><p>微信小程序开发团队将小程序的原生框架叫做MINA。</p><p>MINA的目标是通过尽可能简单，高效的方式让开发者可以在微信中开发具有原生APP体验的服务。</p></blockquote><h4 id="1-1-小程序结构目录"><a href="#1-1-小程序结构目录" class="headerlink" title="1.1 小程序结构目录"></a>1.1 小程序结构目录</h4><blockquote><p>小程序框架提供了自己的视图层描述语言<code>WXML</code>和<code>WXSS</code>，以及<code>JavaScript</code>,并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑</p></blockquote><ul><li>小程序文件结构和传统web对比</li></ul><div class="table-container"><table><thead><tr><th>结构</th><th>传统web</th><th>微信小程序</th></tr></thead><tbody><tr><td>结构</td><td>HTML</td><td>WXML</td></tr><tr><td>样式</td><td>CSS</td><td>WXSS</td></tr><tr><td>逻辑</td><td>JavaScript</td><td>JavaScript</td></tr><tr><td>配置</td><td>无</td><td>JSON</td></tr></tbody></table></div><blockquote><p>传统web是三层结构，而微信小程序是四层结构，多了一层配置.json</p></blockquote><ul><li><p>基本的项目目录</p><p><img src="https://pics.images.ac.cn/image/5eba1df114d4c.html" alt="项目目录说明"></p></li></ul><h4 id="1-2-小程序配置文件"><a href="#1-2-小程序配置文件" class="headerlink" title="1.2 小程序配置文件"></a>1.2 小程序配置文件</h4><blockquote><p>小程序 应用程序中，包括最基本的两种配置文件，一种是全局的app.json和页面自己的page.json</p></blockquote><ul><li><p>全局配置 app.json</p><ul><li><p>字段含义</p><ul><li>pages字段——用于描述当前小程序所有的页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录</li><li>window字段——用于小程序所有页面的顶部背景颜色，文字颜色定义等</li><li>完整的配置信息见官网<ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html" target="_blank" rel="noopener">全局配置中的配置项</a></li></ul></li></ul></li><li><p>示例说明</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在配置文件中，不能拥有注释，这里只做解释说明使用</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"pages"</span>:[</span><br><span class="line">    <span class="comment">// 页面的顺序决定首页的显示内容 </span></span><br><span class="line">    <span class="string">"pages/index/index"</span>,</span><br><span class="line">    <span class="string">"pages/logs/logs"</span>,</span><br><span class="line">    <span class="comment">// 在小程序开发者工具中，通过在配置文件中添加页面，可以自动生成该页面的基本组成成分</span></span><br><span class="line">    <span class="string">"pages/demo/demo"</span></span><br><span class="line">  ], </span><br><span class="line">  <span class="comment">// 窗口配置</span></span><br><span class="line">  <span class="attr">"window"</span>:&#123; </span><br><span class="line">    <span class="comment">// 下拉 loading 的样式，仅支持 dark / light</span></span><br><span class="line">    <span class="attr">"backgroundTextStyle"</span>:<span class="string">"light"</span>,</span><br><span class="line">    <span class="comment">// 是否开启当前页面下拉刷新。</span></span><br><span class="line">    <span class="attr">"enablePullDownRefresh"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 下拉时，展现出的窗口的背景色</span></span><br><span class="line">    <span class="attr">"backgroundColor"</span>: <span class="string">"red"</span>,</span><br><span class="line">   <span class="comment">// 导航栏背景颜色，如 #000000</span></span><br><span class="line">    <span class="attr">"navigationBarBackgroundColor"</span>: <span class="string">"#fff"</span>,</span><br><span class="line">    <span class="comment">// 导航栏标题文字内容</span></span><br><span class="line">    <span class="attr">"navigationBarTitleText"</span>: <span class="string">"WeChat"</span>,</span><br><span class="line">    <span class="comment">// 导航栏标题颜色，仅支持 black / white</span></span><br><span class="line">    <span class="attr">"navigationBarTextStyle"</span>:<span class="string">"black"</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 底部导航栏配置</span></span><br><span class="line">  <span class="attr">"tabBar"</span>: &#123;</span><br><span class="line">    <span class="comment">// 底部导航栏的组成为list的数组中的内容</span></span><br><span class="line">    <span class="attr">"list"</span>: [&#123;</span><br><span class="line">      <span class="comment">// 导航栏导向地址</span></span><br><span class="line">      <span class="attr">"pagePath"</span>: <span class="string">"pagePath"</span>,</span><br><span class="line">      <span class="comment">// 标题</span></span><br><span class="line">      <span class="attr">"text"</span>: <span class="string">"text"</span>,</span><br><span class="line">      <span class="comment">// 未被选中的图标</span></span><br><span class="line">      <span class="attr">"iconPath"</span>: <span class="string">"iconPath"</span>,</span><br><span class="line">      <span class="comment">// 已经选中的图标</span></span><br><span class="line">      <span class="attr">"selectedIconPath"</span>: <span class="string">"selectedIconPath"</span></span><br><span class="line">    &#125;]</span><br><span class="line">      ...底部导航，至少需要两个数组对象</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"style"</span>: <span class="string">"v2"</span>,</span><br><span class="line">  <span class="attr">"sitemapLocation"</span>: <span class="string">"sitemap.json"</span></span><br><span class="line">  <span class="comment">// ...具体且全面的属性列表请查看微信开发文档</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>页面配置</p><ul><li>为每一个页面配置单独配置全局配置中的window属性 </li></ul></li><li><p>sitemap配置</p><ul><li>用于配置小程序及其页面是否允许被微信索引</li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/sitemap.html" target="_blank" rel="noopener">页面索引优化</a></li></ul></li></ul><h3 id="2-小程序的模板语法"><a href="#2-小程序的模板语法" class="headerlink" title="2 小程序的模板语法"></a>2 小程序的模板语法</h3><blockquote><p>WXML是框架设计的一套标签语言，结合基础组件，事件系统，可以构建出页面的结构</p></blockquote><h4 id="2-1-数据绑定"><a href="#2-1-数据绑定" class="headerlink" title="2.1 数据绑定"></a>2.1 数据绑定</h4><ul><li><p>普通写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span> &#123;&#123; message &#125;&#125; <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: <span class="string">'Hello MINA!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>绑定到属性中去</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">checkbox</span> <span class="attr">checked</span>=<span class="string">"&#123;&#123;isChecked&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>小细节<ul><li>字符串和花括号之间不能存在空格，否则会导致识别失败</li></ul></li></ul></li></ul><h4 id="2-2-运算"><a href="#2-2-运算" class="headerlink" title="2.2 运算"></a>2.2 运算</h4><ul><li><p>三元运算</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">hidden</span>=<span class="string">"&#123;&#123;flag ? true : false&#125;&#125;"</span>&gt;</span>是否会隐藏<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>算数运算</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span> &#123;&#123; a + b &#125;&#125; + &#123;&#123; c &#125;&#125; + 3 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        a: <span class="number">1</span>,</span><br><span class="line">        b: <span class="number">2</span>,</span><br><span class="line">        c: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>逻辑判断</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123; length &gt; 5 &#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>字符串运算</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span> &#123;&#123; "hello" + name &#125;&#125; <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">"word"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-列表渲染"><a href="#2-3-列表渲染" class="headerlink" title="2.3 列表渲染"></a>2.3 列表渲染</h4><ul><li><p><code>wx:for</code></p><ul><li><code>item</code><ul><li>项的变量名默认为<code>item</code></li><li><code>wx:for-item</code> 可以指定数组当前元素的变量名</li></ul></li><li><code>index</code><ul><li>下标变量名默认为<code>index</code></li><li><code>wx:for-index</code> 可以指定数组当前元素下标的变量名</li></ul></li></ul></li><li><p><code>wx:key</code></p><ul><li>用来提升数组渲染的性能</li><li>绑定的值为字符串名称，该字符串的值必须唯一不重复<ul><li>特殊的绑定值:保留字 <code>*this</code>，就表示绑定了循环项</li></ul></li></ul></li><li><p>小细节: 当出现嵌套循环的时候，绑定的属性名不可以重复</p></li><li><p>循环数组示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123; array &#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"id"</span> <span class="attr">wx:for-item</span>=<span class="string">"item"</span> <span class="attr">wx:for-index</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">&#123;&#123; index &#125;&#125;: &#123;&#123; item.msg &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    array: [</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">msg</span>: <span class="string">"a"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">msg</span>: <span class="string">"b"</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>循环对象示例</p><blockquote><p>当循环对象的时候，item指向对象的值，index指向对象的属性</p><p>建议修改名称，避免歧义</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;person&#125;&#125;"</span> <span class="attr">wx:for-item</span>=<span class="string">"value"</span> <span class="attr">wx:for-index</span>=<span class="string">"key"</span> <span class="attr">wx:key</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">&#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    person: &#123;</span><br><span class="line">        id: <span class="number">1625</span>,</span><br><span class="line">        name: <span class="string">"abel"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>block</code></p><blockquote><p>渲染一个包含多节点的结构快，block最终不会变成真正的dom元素</p></blockquote></li></ul><h4 id="2-4-条件渲染"><a href="#2-4-条件渲染" class="headerlink" title="2.4 条件渲染"></a>2.4 条件渲染</h4><ul><li><p><code>wx:if</code></p><ul><li><p>判断代码块是否需要渲染</p></li><li><p>if代码块的使用</p><ul><li><code>wx:if</code></li><li><code>wx:elif</code></li><li><code>wx:else</code></li></ul></li></ul></li><li><p><code>wx:hidden</code></p><ul><li>判断代码块是否需要显示</li></ul></li><li><p>使用场景</p><ul><li>当标签频繁的切换显示的时候，使用hidden,反之则使用if</li><li>hidden属性不能同display一起使用，会被覆盖</li></ul></li></ul><h3 id="3-小程序事件的绑定"><a href="#3-小程序事件的绑定" class="headerlink" title="3 小程序事件的绑定"></a>3 小程序事件的绑定</h3><h4 id="3-1-事件类型"><a href="#3-1-事件类型" class="headerlink" title="3.1 事件类型"></a>3.1 事件类型</h4><ul><li><code>bindtap</code>：点击</li><li><code>bindinput</code>： input输入</li><li><code>bindchange</code>： 数值改变</li></ul><h4 id="3-2-操作数值"><a href="#3-2-操作数值" class="headerlink" title="3.2 操作数值"></a>3.2 操作数值</h4><ul><li><code>this.setData</code></li></ul><h4 id="3-3-除value以外的传参"><a href="#3-3-除value以外的传参" class="headerlink" title="3.3 除value以外的传参"></a>3.3 除value以外的传参</h4><ul><li><p>自定义属性传参</p><p><code>data-value=&quot;1&quot;</code></p></li><li><p>通过事件源对象获取参数</p><p><code>e.currentTarget.dataset.operation;</code></p></li><li><p>示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">bindinput</span>=<span class="string">"handleInput"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    value: <span class="string">''</span>,</span><br><span class="line">    <span class="comment">// 绑定的事件</span></span><br><span class="line">    handleInput: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">            value: e.detail.value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-小程序的样式书写"><a href="#4-小程序的样式书写" class="headerlink" title="4 小程序的样式书写"></a>4 小程序的样式书写</h3><blockquote><p>WXSS是一套样式语言，用于描述WXML的组件样式</p></blockquote><p>特征：</p><ul><li>响应式长度单位：<code>rpx</code></li><li>样式导入</li></ul><h4 id="4-1-尺寸单位"><a href="#4-1-尺寸单位" class="headerlink" title="4.1 尺寸单位"></a>4.1 尺寸单位</h4><blockquote><p><code>rpx</code> : 可以根据屏幕宽度进行自适应，规定屏幕宽为<code>750px</code>。</p><p>因为微信的独特测量单位，与传统的px不同，因此，如果要根据PS的设计稿设计尺寸，需要 遵从以下步骤：</p></blockquote><ul><li><p>手动计算</p><ul><li>确定设计稿的宽度，设为：pageWidth</li><li>确认比例，<code>750rpx = pageWidth px</code></li><li>根据比例确认<code>rpx</code>值</li></ul></li><li><p>利用<code>calc</code>属性转换</p><ul><li><p><code>css</code>和<code>wxss</code>都支持<code>calc</code>属性，因此可以使用<code>calc</code>转换</p></li><li><p>根据示例，没有空格的地方不允许有多余的空格</p></li><li><p>格式：<code>width:calc(750rpx * 元素尺寸 / pageWidth)</code></p></li><li><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">view</span>&#123;</span><br><span class="line">    <span class="comment">/* 在设计稿为375px情况下，100px的元素在小程序中占多少rpx */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">750</span>rpx * <span class="number">100</span> / <span class="number">375</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>建议：开发微信小程序时使用iPhone6作为视觉参考</p></li></ul><h4 id="4-2-样式导入"><a href="#4-2-样式导入" class="headerlink" title="4.2 样式导入"></a>4.2 样式导入</h4><ul><li><code>wxss</code>直接就支持样式的导入功能，也可以和less中的导入混合使用</li><li>使用<code>@import</code>语句可以导入外联样式表，但是只支持相对路径</li></ul><h4 id="4-3-选择器"><a href="#4-3-选择器" class="headerlink" title="4.3 选择器"></a>4.3 选择器</h4><blockquote><p>特别注意：小程序不支持 <code>*</code> 通配符</p></blockquote><ul><li>目前支持的选择器有</li></ul><div class="table-container"><table><thead><tr><th>选择器</th><th>样例</th><th>样例描述</th></tr></thead><tbody><tr><td>.class</td><td><code>.intro</code></td><td>选择所有拥有class=”intro”的组件</td></tr><tr><td>#id</td><td><code>#firstname</code></td><td>选择拥有id=”firstname”的组件</td></tr><tr><td>element</td><td><code>view</code></td><td>选择所有view组件</td></tr><tr><td>element, element</td><td><code>view, checkbox</code></td><td>选择所有文档的view组件和所有的checkbox组件</td></tr><tr><td>nth-child(n)</td><td><code>view:nth-child(n)</code></td><td>选择某个索引的 标签</td></tr><tr><td>::after</td><td><code>view::after</code></td><td>在view组件后面插入内容</td></tr><tr><td>::before</td><td><code>view::before</code></td><td>在view组件前面插入内容</td></tr></tbody></table></div><h4 id="4-4-小程序中使用less"><a href="#4-4-小程序中使用less" class="headerlink" title="4.4 小程序中使用less"></a>4.4 小程序中使用less</h4><blockquote><p>引入插件使原生小程序支持less</p></blockquote><ul><li><p>编辑器为：<code>vscode</code></p></li><li><p>安装插件：<code>easy less</code></p></li><li><p>配置插件</p><ul><li><p><code>settings</code>配置</p></li><li><p>配置内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"less.compile"</span>: &#123;</span><br><span class="line">    <span class="string">"outExt"</span>: <span class="string">".wxss"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>less</code>文件，保存自动生成<code>wxss</code>文件</p></li></ul></li></ul><h3 id="5-小程序的内置组件"><a href="#5-小程序的内置组件" class="headerlink" title="5 小程序的内置组件"></a>5 小程序的内置组件</h3><blockquote><p>重点讲解小程序中常用的布局组件</p></blockquote><h4 id="5-1-view"><a href="#5-1-view" class="headerlink" title="5.1 view"></a>5.1 <code>view</code></h4><ul><li><p>代替原来的<code>div</code>标签</p></li><li><p>增加的属性</p></li></ul><div class="table-container"><table><thead><tr><th>属性名</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>hover-class</td><td>string</td><td>none</td><td>指定按下去的样式类</td></tr><tr><td>hover-stop-propagation</td><td>boolean</td><td>false</td><td>指定是否阻止本结点的祖先结点出现点击状态</td></tr><tr><td>hover-start-time</td><td>number</td><td>50</td><td>按住后多久出现点击状态</td></tr><tr><td>hover-stay-time</td><td>number</td><td>400</td><td>手指松开点击状态保留多久</td></tr></tbody></table></div><h4 id="5-2-text"><a href="#5-2-text" class="headerlink" title="5.2 text"></a>5.2 <code>text</code></h4><ul><li><p>文本标签</p></li><li><p>只能嵌套<code>text</code></p></li><li><p>增加属性</p></li></ul><div class="table-container"><table><thead><tr><th>属性名</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>selectable</td><td>Boolean</td><td>false</td><td>用户长按该标签可以复制内容，只有该标签拥有这个功能</td></tr><tr><td>decode</td><td>Boolean</td><td>false</td><td>可以对 <em>空格</em> <em>回车</em>  等 符号 进行编码</td></tr></tbody></table></div><h4 id="5-3-image"><a href="#5-3-image" class="headerlink" title="5.3 image"></a>5.3 <code>image</code></h4><ul><li><p>图片标签，默认的宽和高为：320px*240px</p></li><li><p>由于微信对静态文件大小的限制，推荐使用：<a href="https://images.ac.cn/simple.html" target="_blank" rel="noopener">土豆图床</a></p></li><li><p>支持懒加载</p><ul><li>lazy-load 会自己判断，当图片出现在视口上下三屏的高度之内的时候，自己开始加载图片</li></ul></li><li><p>新增属性</p></li></ul><div class="table-container"><table><thead><tr><th>属性名</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>src</td><td>String</td><td></td><td>图片资源地址</td></tr><tr><td>mode</td><td>String</td><td>‘scaleToFill’</td><td>图片裁剪，缩放的模式</td></tr><tr><td>lazy-load</td><td>Boolean</td><td>false</td><td>图片懒加载</td></tr></tbody></table></div><ul><li>mode的有效值：</li></ul><div class="table-container"><table><thead><tr><th>模式</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>缩放</td><td>scaleToFill</td><td>不保持纵横比缩放图片，使图片的宽高完全拉伸至填满jmage元素</td></tr><tr><td>缩放</td><td>aspectFit</td><td>保持纵横比缩放图片，使图片的长边能完全显示出来</td></tr><tr><td>缩放</td><td>aspectFill</td><td>保持纵横比缩放图片，只保证图片的短边能完全显示出来</td></tr><tr><td>缩放</td><td>widthFix</td><td>宽度不变，高度自动变化，保持原图宽高比不变</td></tr><tr><td>裁剪</td><td>top,<br>bottom,<br>center,<br>left,<br>right,<br>top left,<br>top right,<br></td><td>不缩放图片，只显示图片的部分区域</td></tr><tr><td>裁剪</td><td>bottom</td><td>不缩放</td></tr></tbody></table></div><h4 id="5-4-swiper"><a href="#5-4-swiper" class="headerlink" title="5.4 swiper"></a>5.4 <code>swiper</code></h4><blockquote><p>微信内置轮播图组件</p></blockquote><ul><li><p><code>swiper</code>：轮播图外层容器 </p></li><li><p><code>swiper-item</code>：每一个轮播项，宽自动占满整行，高由内容撑开</p></li><li><p><code>swiper</code> 拥有默认样式，并且高度无法由内容撑开，因此我们需要设置<code>swiper</code>高度，通过内容图片的高度来计算</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 100%</span><br><span class="line"><span class="selector-tag">height</span>: 150<span class="selector-tag">px</span></span><br></pre></td></tr></table></figure><ul><li><code>swiper</code> 高度的计算<ul><li>公式：<code>swiper</code>的高度/<code>swiper</code>的宽度=原图的高度/原图的宽度<ul><li>height = <code>swiper</code>的宽度*原图的高度/原图的宽度</li></ul></li><li>宽度一般采用<code>vw</code>来表示，根据视口控制图片所占百分比</li></ul></li></ul></li><li><p><code>swiper</code>的标签属性</p></li></ul><div class="table-container"><table><thead><tr><th>属性名</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>indicator-dots</td><td>Boolean</td><td>false</td><td>是否显示面板知识点</td></tr><tr><td>indicator-color</td><td>Color</td><td>rgba(0,0,0,3)</td><td>指示点颜色</td></tr><tr><td>indicator-active-color</td><td>Color</td><td>#000</td><td>当前选中的指示点颜色</td></tr><tr><td>autoplay</td><td>Boolean</td><td>false</td><td>是否自动切换</td></tr><tr><td>interval</td><td>Number</td><td>5000</td><td>自动切换时间间隔</td></tr><tr><td>circular</td><td>Boolean</td><td>false</td><td>是否开启循环轮播，用于最后一张和第一张的衔接</td></tr></tbody></table></div><h4 id="5-5-navigator"><a href="#5-5-navigator" class="headerlink" title="5.5 navigator"></a>5.5 <code>navigator</code></h4><blockquote><p>导航组件，类似于超链接标签</p><p>块级元素，支持宽高的设定</p></blockquote><ul><li><code>navigator</code> 的属性</li></ul><div class="table-container"><table><thead><tr><th>属性名</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>target</td><td>String</td><td>self</td><td>在哪个目标上发生跳转，默认当前小程序，可选值self/miniProgram</td></tr><tr><td>url</td><td>String</td><td></td><td>当前小程序内的跳转链接</td></tr><tr><td>open-type</td><td>String</td><td>navigate</td><td>跳转方式</td></tr></tbody></table></div><ul><li>open-type的有效值</li></ul><div class="table-container"><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>navigate</td><td>保留当前页面，跳转到应用内的某个页面，但是不能跳转到tabbar页面</td></tr><tr><td>redirect</td><td>关闭当前页面，跳转到应用内的某个页面，但是不允许跳转到tabbar页面</td></tr><tr><td>switchTab</td><td>跳转到tabBar页面，并关闭其他所有非tabBar页面</td></tr><tr><td>reLaunch</td><td>关闭所有页面，打开到应用内的某个页面</td></tr><tr><td>navigateBack</td><td>关闭当前页面，返回上一页面或多级页面。可以通过getCurrentPages()获取当前的页面栈，决定需要返回几层</td></tr><tr><td>exit</td><td>退出小程序，target=”miniProgram”时生效</td></tr></tbody></table></div><h4 id="5-6-rich-text"><a href="#5-6-rich-text" class="headerlink" title="5.6 rich-text"></a>5.6 <code>rich-text</code></h4><blockquote><p>富文本标签</p></blockquote><ul><li><p>可以将字符串解析为对应的标签，类似于vue中的<code>v-html</code>功能</p></li><li><p><code>nodes</code> 属性，根据该属性的接收内容，渲染标签内容</p><ul><li>接收标签字符串<ul><li>例如：<code>&lt;div&gt;助人者，人恒助之&lt;/div&gt;</code></li></ul></li><li>接收对象数组，对象的属性<ul><li>name<ul><li>决定是什么类型的标签</li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/rich-text.html" target="_blank" rel="noopener">查看都支持什么标签</a></li></ul></li><li>attres<ul><li>决定标签的属性</li></ul></li><li>children<ul><li>决定子节点的内容，嵌套使用</li></ul></li></ul></li></ul></li><li><p>示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rich-text</span> <span class="attr">nodes</span>=<span class="string">"&#123;&#123;html&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">rich-text</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    html: [</span><br><span class="line">        name: <span class="string">"div"</span>,</span><br><span class="line">        attrs: &#123;</span><br><span class="line">        class: "my_div",</span><br><span class="line">        style: <span class="string">"color: red"</span></span><br><span class="line">        &#125;,</span><br><span class="line">     children: [</span><br><span class="line">     &#123;</span><br><span class="line">     name: <span class="string">"p"</span>,</span><br><span class="line">     attrs: &#123;&#125;,</span><br><span class="line">    children: &#123;</span><br><span class="line">            .....</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ]</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-7-button"><a href="#5-7-button" class="headerlink" title="5.7 button"></a>5.7 <code>button</code></h4><blockquote><p>按钮标签</p></blockquote><ul><li><code>button</code> 的属性</li></ul><div class="table-container"><table><thead><tr><th>属性</th><th>类型</th><th>默认值</th><th>必填</th><th>说明</th></tr></thead><tbody><tr><td>size</td><td>string</td><td>default</td><td>否</td><td>按钮的大小</td></tr><tr><td>type</td><td>string</td><td>default</td><td>否</td><td>按钮的样式类型</td></tr><tr><td>plain</td><td>boolean</td><td>false</td><td>否</td><td>按钮是否镂空，背景色透明</td></tr><tr><td>disabled</td><td>boolean</td><td>false</td><td>否</td><td>是否禁用</td></tr><tr><td>loading</td><td>boolean</td><td>false</td><td>否</td><td>名称前是否带loading图标</td></tr><tr><td>form-type</td><td>string</td><td></td><td>否</td><td>用于form组件，点击分别会触发form组件的submit/reset事件</td></tr><tr><td>open-type</td><td>string</td><td></td><td>否</td><td>微信开发能力，超能力</td></tr></tbody></table></div><ul><li>size的合法值</li></ul><div class="table-container"><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>default</td><td>默认大小</td></tr><tr><td>mini</td><td>小尺寸</td></tr></tbody></table></div><ul><li>type的合法值</li></ul><div class="table-container"><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>primary</td><td>绿色</td></tr><tr><td>default</td><td>白色</td></tr><tr><td>warn</td><td>红色</td></tr></tbody></table></div><ul><li>form-type的合法值</li></ul><div class="table-container"><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>submit</td><td>提交表单</td></tr><tr><td>reset</td><td>重置表单</td></tr></tbody></table></div><ul><li><p>特别说明，关于<a href="https://developers.weixin.qq.com/miniprogram/dev/component/button.html" target="_blank" rel="noopener">open-type</a> </p><ul><li><code>open-type</code>的合法值</li></ul></li></ul><div class="table-container"><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>contact</td><td>打开客服会话，如果用户在会话中点击消息卡片后返回小程序，可以从bindcontact回调中获得具体消息，需真机调试</td></tr><tr><td>share</td><td>触发用户转发，需真机调试</td></tr><tr><td>getPhoneNumber</td><td>获取用户手机，可以从bindgetphonenumber回调中获取到用户信息</td></tr><tr><td>getUserInfo</td><td>获取用户信息，可以从bindgetuserinfo回调中获取到用户信息</td></tr><tr><td>launchApp</td><td>打开APP，可以通过app-parameter属性设定向APP传的参数，需真机调试</td></tr><tr><td>openSetting</td><td>打开授权设置页</td></tr><tr><td>feedback</td><td>打开”意见反馈“页面，用户可以提交反馈内容并上传日志，开发者可以登录<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">小程序管理后台</a>查看，需真机调试</td></tr></tbody></table></div><ul><li><p><code>contact</code> </p><ul><li>作用：直接打开客服对话功能</li><li>前提：非测试号。需要在微信小程序的后台配置，添加客服，并使用真机调试</li><li><img src="https://pics.images.ac.cn/image/5eb973aa42ee5.html" alt="添加客服"></li></ul></li><li><p><code>getPhoneNumber</code> </p><ul><li>作用：获取当前用户的手机号码信息</li><li>前提：需为企业的小程序账号，才有权限获取用户的手机号码</li><li>方法：<ul><li>绑定事件: <code>bindgetphonenumber</code></li><li>在事件的回调函数中，通过参数来获取信息</li><li>获取信息为加密信息，通过小程序的后台服务器，进行解析再返</li></ul></li></ul></li><li><p><code>launchApp</code></p><ul><li><p>作用：请求打开本机上装的APP</p></li><li><p>前提：</p><ul><li><p>APP和小程序为同一人认证的开放平台账号</p></li><li><p>APP接入微信终端SDK</p></li></ul></li><li><p>方法：</p><ul><li><p>通过 open-type 属性值设置为 launchApp 的 组件</p></li><li><p>设置 app-parameter 传递的参数</p></li></ul></li></ul></li></ul><h4 id="5-7-icon"><a href="#5-7-icon" class="headerlink" title="5.7 icon"></a>5.7 <code>icon</code></h4><blockquote><p>图标</p></blockquote><ul><li><code>icon</code> 的属性</li></ul><div class="table-container"><table><thead><tr><th>属性</th><th>类型</th><th>默认值</th><th>必填</th><th>说明</th></tr></thead><tbody><tr><td>type</td><td>string</td><td></td><td>是</td><td>icon的类型，有效值：success,success_no_circle,info,warn,waiting,cancel</td></tr><tr><td>size</td><td>number/string</td><td>23</td><td>否</td><td>icon的大小</td></tr><tr><td>color</td><td>string</td><td></td><td>否</td><td>icon的颜色，同css的color</td></tr></tbody></table></div><h4 id="5-8-radio"><a href="#5-8-radio" class="headerlink" title="5.8 radio"></a>5.8 <code>radio</code></h4><blockquote><p>单选框</p></blockquote><ul><li><code>radio</code> 的属性</li></ul><div class="table-container"><table><thead><tr><th>属性</th><th>类型</th><th>必填</th><th>说明</th></tr></thead><tbody><tr><td>color</td><td>string</td><td>否</td><td>按钮颜色</td></tr><tr><td>value</td><td>string</td><td>是</td><td>选中时候，传给父组件的值</td></tr></tbody></table></div><ul><li>搭配父元素 <code>radio-group</code> 来使用，并且需要给radio-group绑定change事件才能让选项生效，记录，通过数据源对象的detail属性获取</li></ul><h4 id="5-9-checkbox-group"><a href="#5-9-checkbox-group" class="headerlink" title="5.9 checkbox-group"></a>5.9 <code>checkbox-group</code></h4><blockquote><p>复选框</p></blockquote><ul><li><p><code>checkbox</code> 的内容渲染使用<strong>数组循环渲染</strong>为佳</p></li><li><p>数组组成示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        list:[</span><br><span class="line">            &#123;</span><br><span class="line">                id: <span class="number">0</span>,</span><br><span class="line">                name: <span class="string">"🍉"</span>,</span><br><span class="line">                value: <span class="string">"watermelon"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                id: <span class="number">1</span>,</span><br><span class="line">                name: <span class="string">"🍓"</span>,</span><br><span class="line">                value: <span class="string">"strawberry"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>搭配父元素 <code>radio-group</code> 来使用，并且需要给radio-group绑定change事件才能让选项生效，记录，通过数据源对象的detail属性获取</p></li></ul><h3 id="6-自定义组件"><a href="#6-自定义组件" class="headerlink" title="6 自定义组件"></a>6 自定义组件</h3><blockquote><p>类似于vue或者react中的自定义组件</p></blockquote><h4 id="6-1-如何创建自定义组件"><a href="#6-1-如何创建自定义组件" class="headerlink" title="6.1 如何创建自定义组件"></a>6.1 如何创建自定义组件</h4><blockquote><p>类似于创建页面 ，但是创建的是Component，一个自定义组件由<code>json</code>,<code>wxml</code>,<code>wxss</code>,<code>js</code>4个文件组成</p></blockquote><ul><li><p>在微信开发者工具中搭建目录结构，快速创建组件的文件结构</p><p><img src="https://pics.images.ac.cn/image/5eba1b9ac3702.html" alt="自定义组件"></p></li><li><p>在/components的文件夹下，根据所需自定义的组件名，来命名组件文件夹，然后再通过新建<code>Component</code>来自动生成自定义组件的文件组成部分</p></li></ul><h4 id="6-2-如何搭建自定义组件"><a href="#6-2-如何搭建自定义组件" class="headerlink" title="6.2 如何搭建自定义组件"></a>6.2 如何搭建自定义组件</h4><blockquote><p>这里我们通过搭建一个名为Tabs的组件记录搭建过程</p></blockquote><ul><li><p>声明组件</p><ul><li><p>需要在<strong>组件</strong>的<code>json</code>文件中进行自定义组件声明<code>Tabs.json</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"component"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<strong>需要调用该组件的页面</strong>的<code>json</code>文件中声明使用<code>Tabs.json</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"usingComponents"</span>: &#123;</span><br><span class="line">        <span class="string">"Tabs"</span>: <span class="string">"../../components/Tabs/Tabs"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在调用过该组件的页面，直接使用即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Tabs</span>&gt;</span><span class="tag">&lt;/<span class="name">Tabsr</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>修改组件内容</p><ul><li><p>根据需求更改搭建组件内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--components/Tabs/Tabs.wxml--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自定义组件：tabs --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"tabs"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标题区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"tabs_title"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span></span></span><br><span class="line"><span class="tag">        <span class="attr">wx:for</span>=<span class="string">"&#123;&#123; tabs &#125;&#125;"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">wx:key</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"title_item &#123;&#123; item.isActive? 'active' : '' &#125;&#125;"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">bindtap</span>=<span class="string">"hanldeItemTap"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">data-index</span>=<span class="string">"&#123;&#123;index&#125;&#125;"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">            &#123;&#123; item.name &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内容区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"tabs_content"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这里是内容区域，会根据标题的改变而改变 </span></span><br><span class="line"><span class="comment">solt标签，其实就是一个占位符插槽，等到父组件调用子组件的时候，再传递标签过来，最终这些传递的标签就会替代slot插槽的位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>利用组件的两个要点，参数的传递</p><ul><li><p>父传子</p><ul><li><p>通过属性传递,在父组件定义数据，传递给子组件的自定义属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Tabs</span> <span class="attr">tabs</span>=<span class="string">"&#123;&#123;tabs&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">Tabs</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义自定义属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 组件的属性列表</span></span><br><span class="line"><span class="comment">   * 这里面存放的是要从父组件中接收的数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  properties: &#123;</span><br><span class="line">    <span class="comment">// 要接收的数据</span></span><br><span class="line">    tabs: &#123;</span><br><span class="line">      <span class="comment">// type 要接收的数据的类型</span></span><br><span class="line">      type: <span class="built_in">Array</span>,</span><br><span class="line">      <span class="comment">// value 默认值</span></span><br><span class="line">      value: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>子传父</p><ul><li><p>通过函数方法传递</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="comment">// 在子组件中正常调用该方法</span></span><br><span class="line">    hanldeItemTap (e) &#123;</span><br><span class="line">        <span class="comment">// 触发父组件中的自定义事件，同时传递数据给父组件</span></span><br><span class="line">        <span class="keyword">this</span>.triggerEvent(<span class="string">"itemChange"</span>,&#123;index&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>父组件通过绑定事件到子组件的自定义方法来操作数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自定义方法，前面需要加上触发方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Tabs</span> <span class="attr">tabs</span>=<span class="string">"&#123;&#123;tabs&#125;&#125;"</span> <span class="attr">binditemChange</span>=<span class="string">"hanldeItemChange"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">Tabs</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>根据标签改变内容</p><ul><li><p>插槽，if-elif-else的运用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Tabs</span> <span class="attr">tabs</span>=<span class="string">"&#123;&#123;tabs&#125;&#125;"</span> <span class="attr">binditemChange</span>=<span class="string">"hanldeItemChange"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;tabs[0].isActive&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:elif</span>=<span class="string">"&#123;&#123;tabs[1].isActive&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:elif</span>=<span class="string">"&#123;&#123;tabs[2].isActive&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:else</span>&gt;</span><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Tabs</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>逻辑分析</p><blockquote><p>封装并使用一个组件</p><ol><li><p>创建组件,搭建组件的基本样式，基本结构</p></li><li><p>组件的内容渲染，数据应该由父组件传递到子组件，通过自定义属性</p></li><li>在父组件中操作的时候，无法直接在子组件中调用方法改变数据，因为数据来自于父组件，这里我们通过自定义方法，调用父组件中的方法来改变父组件中的数据</li><li>根据标题的改变，改变内容，子组件预留插槽占位符，父组件根据标签选中，利用if-elif-else来渲染页面</li></ol></blockquote></li></ul><h4 id="6-3-组件的字段定义与示例方法"><a href="#6-3-组件的字段定义与示例方法" class="headerlink" title="6.3 组件的字段定义与示例方法"></a>6.3 组件的字段定义与示例方法</h4><blockquote><p><code>Component</code> 构造器可用于定义组件，调用<code>Component</code> 构造器时可以指定组件的属性，数据，方法等</p></blockquote><div class="table-container"><table><thead><tr><th>定义段</th><th>类型</th><th>是否必填</th><th>描述</th></tr></thead><tbody><tr><td>properties</td><td>Object Map</td><td>否</td><td>组件的对外属性，是属性名到属性设置的映射表</td></tr><tr><td>data</td><td>Object</td><td>否</td><td>组件的内部数据，和<code>properties</code> 一同用于组件的模板渲染</td></tr><tr><td>observers</td><td>Object</td><td>否</td><td>组件数据字段监听器，用于监听properties和data的变化，<a href="https://developers.weixin.qq.com/miniprogram/dev/extended/utils/computed.html" target="_blank" rel="noopener">官网示例</a></td></tr><tr><td>methods</td><td>Object</td><td>否</td><td>组件的方法，包括事件响应函数和任意的自定义方法，关于事件响应函数的使用</td></tr><tr><td>created</td><td>Function</td><td>否</td><td>组件生命周期函数，在组件实例刚刚被创建时执行，注意此时不能调用</td></tr><tr><td>attached</td><td>Function</td><td>否</td><td>组件生命周期函数，在组件实例进入页面节点树时执行</td></tr><tr><td>ready</td><td>Function</td><td>否</td><td>组件生命周期函数，在组件布局完成后执行</td></tr><tr><td>moved</td><td>Function</td><td>否</td><td>组件生命周期函数，在组件实例被移动到节点树另一个位置时执行</td></tr><tr><td>detached</td><td>Function</td><td>否</td><td>组件生命周期函数，在组件实例被从页面节点树移除时执行</td></tr></tbody></table></div><h3 id="7-小程序的生命周期"><a href="#7-小程序的生命周期" class="headerlink" title="7 小程序的生命周期"></a>7 小程序的生命周期</h3><blockquote><p>小程序的生命周期分为应用生命周期和页面生命周期</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/operating-mechanism.html" target="_blank" rel="noopener">运行机制</a></p></blockquote><h4 id="7-1-应用生命周期"><a href="#7-1-应用生命周期" class="headerlink" title="7.1 应用生命周期"></a>7.1 应用生命周期</h4><blockquote><p>小程序入口文件app.js</p></blockquote><div class="table-container"><table><thead><tr><th>属性</th><th>类型</th><th>默认值</th><th>必填</th><th>说明</th></tr></thead><tbody><tr><td>onLaunch</td><td>function</td><td></td><td>否</td><td>监听小程序初始化/启动</td></tr><tr><td>onShow</td><td>function</td><td></td><td>否</td><td>监听小程序启动或切前台/展现页面的时候</td></tr><tr><td>onHide</td><td>function</td><td></td><td>否</td><td>监听小程序切后台/隐藏页面</td></tr><tr><td>onError</td><td>function</td><td></td><td>否</td><td>错误监听函数/错误收集</td></tr><tr><td>onPageNotFound</td><td>function</td><td></td><td>否</td><td>页面不存在监听函数</td></tr></tbody></table></div><h4 id="7-2-页面生命周期"><a href="#7-2-页面生命周期" class="headerlink" title="7.2 页面生命周期"></a>7.2 页面生命周期</h4><div class="table-container"><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>data</td><td>Object</td><td>页面的初始数据</td></tr><tr><td>onLoad</td><td>function</td><td>生命周期回调——监听页面加载</td></tr><tr><td>onShow</td><td>function</td><td>生命周期回调——监听页面显示</td></tr><tr><td>onReady</td><td>function</td><td>生命周期回调——监听页面初始渲染完成</td></tr><tr><td>onHide</td><td>function</td><td>生命周期回调——监听页面隐藏/跳转</td></tr><tr><td>onUnload</td><td>function</td><td>生命周期回调——监听页面装卸/关闭当前页跳转</td></tr><tr><td>onPullDownRefresh</td><td>function</td><td>监听用户下拉动作(<strong>需开启允许下拉刷新</strong>),用于刷新</td></tr><tr><td>onReachBottom</td><td>function</td><td>页面上拉触底事件的处理函数,用于加载数据或提示已触底</td></tr><tr><td>onShellAppMessage</td><td>function</td><td>用户点击右上角转发</td></tr><tr><td>onPageScroll</td><td>function</td><td>页面滚动触发事件的处理函数</td></tr><tr><td>onResize</td><td>function</td><td>页面尺寸改变时触发，用于横竖屏分屏切换的时候(需开启<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/resizable.html" target="_blank" rel="noopener">屏幕旋转支持</a>)</td></tr><tr><td>onTabltemTap</td><td>function</td><td>当前页时tab页时，点击自己中tab选项时才能触发</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 前端学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于VS Code的学习笔记</title>
      <link href="/2020/05/10/%E5%85%B3%E4%BA%8EVS-Code%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/10/%E5%85%B3%E4%BA%8EVS-Code%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>工欲善其事必先利其器</p><p>关于vscode的学习笔记</p></blockquote><h2 id="1-Command-Palette命令面板"><a href="#1-Command-Palette命令面板" class="headerlink" title="1 Command Palette命令面板"></a>1 Command Palette命令面板</h2><ul><li><p>命令面板：<code>Ctrl+Shift+P</code></p><ul><li>可以快速打开命令面板，命令面板可以执行各种命令</li><li>面板命令为模糊查询，记住关键词即可  </li><li>常用的命令，有快捷键的优先使用快捷键<ul><li><code>Minimap</code>：缩略图</li></ul></li></ul></li><li><p>快捷键：</p><ul><li><code>Ctrl+k,Ctrl+M</code>：快捷键的映射，通过安装扩展，可以使用之前熟悉的软件的快捷键</li><li><code>Ctrl+k,Ctrl+S</code>：在编辑器中查看所有的快捷键<ul><li>当安装扩展后，可能会发生快捷键冲突，可以在这里查询并更改</li></ul></li><li><code>Ctrl+K,Ctrk+R</code>：打开网址<ul><li><a href="https://files.cnblogs.com/files/skyraker/VSCODE_%E5%BF%AB%E6%8D%B7%E9%94%AE.7z" target="_blank" rel="noopener">网上搜罗到的有中文对照的快捷键图例，点击下载</a></li></ul></li></ul></li><li><p>常用快捷键</p><ul><li><code>Ctrl+B</code>：侧边栏的显示与隐藏</li><li><p><code>Ctrl+P</code>：将允许您通过键入其他名称导航到任何文件或符号</p></li><li><p><code>Ctrl+Shift+Tab</code>：将循环浏览最后一组打开的文件</p></li><li><code>Ctrl+Shift+O</code>：将允许您导航到文件中的特定符号</li><li><code>Ctrl+G</code>：将允许您导航到文件中的特定行</li><li>Ctrl+`：可以查看程序输出、调试输出、问题输出和终端命令<ul><li>Ctrl+Shift+`：新建终端</li></ul></li><li><code>Ctrl+K之后Ctrl+T</code>：开启主题切换，回车确认主题的更改<ul><li>更多主题：扩展中搜索<code>theme</code></li><li>自定义配置：见视图配置项<code>Settings</code></li></ul></li></ul></li></ul><h2 id="2-编辑器视图的控制"><a href="#2-编辑器视图的控制" class="headerlink" title="2 编辑器视图的控制"></a>2 编辑器视图的控制</h2><ul><li><p>编辑器视图，单击文件就可以在编辑器中打开视图，可以同时打开多个文件以不同的方式。</p></li><li><p>可以对编辑器进行配置，例如：字体，颜色，字号登等</p><ul><li>命令：<code>&gt;Open Settings (UI)</code> || <code>&gt;Open Settings (JSON)</code></li></ul></li></ul><h2 id="3-VS-Code基本代码编写"><a href="#3-VS-Code基本代码编写" class="headerlink" title="3  VS Code基本代码编写"></a>3  VS Code基本代码编写</h2><blockquote><p>小细节：</p><ul><li>打开文件单击与双击的区别。单击为浏览状态，单击其他文件的时候会被替换。</li></ul></blockquote><h3 id="3-1-快捷键"><a href="#3-1-快捷键" class="headerlink" title="3.1 快捷键"></a>3.1 快捷键</h3><ul><li><p>最常用的快捷键列表如下</p><p>| 快捷键        | 意义       |<br>| ——————- | ————— |<br>| Ctrl+P        | 浏览文件   |<br>| Ctrl+Shift+F  | 查找       |<br>| Ctrl+W        | 关闭文件   |<br>| Ctrl+/        | 注释       |<br>| Shift+Alt+A   | 块注释     |<br>| Shift+Alt+F   | 格式化文档 |<br>| Ctrl+K,Ctrl+F | 格式化选中 |<br>| Ctrl+Shift+K  | 删除行     |<br>|               |            |</p></li></ul><h3 id="3-2-选择多行"><a href="#3-2-选择多行" class="headerlink" title="3.2 选择多行"></a>3.2 选择多行</h3><ul><li><p><code>Alt+click</code> || <code>Ctrl+Alt+按住滑轮上下滑动</code> ：插入多个光标</p></li><li><p><code>Ctrl+D</code>：选择相同的word</p></li></ul><h2 id="4-VS-Code扩展市场"><a href="#4-VS-Code扩展市场" class="headerlink" title="4 VS Code扩展市场"></a>4 VS Code扩展市场</h2><blockquote><p>VS Code之所以强大，就是因为可以添加扩展，并且扩展丰富，好用</p></blockquote><p>4.1 使用VS Code扩展</p><ul><li><p>浏览扩展</p></li><li><p>安装扩展</p></li><li><p>扩展详细</p></li><li><p>过滤扩展</p></li><li><p>排序扩展</p></li><li><p>搜索扩展</p></li><li><p>管理扩展</p><ul><li><p>安装</p></li><li><p>装卸</p></li><li>启用</li><li>禁用</li></ul></li><li><p>扩展分类</p></li><li><p>更新扩展</p></li></ul><h2 id="5-VS-Code-代码补全-IntelliSense"><a href="#5-VS-Code-代码补全-IntelliSense" class="headerlink" title="5 VS Code 代码补全(IntelliSense)"></a>5 VS Code 代码补全(IntelliSense)</h2><blockquote><p>VS Code的代码补全功能依赖各种扩展，例如：java、Python、Go、C#等等，IntellSense可以实现代码补全，内容辅助，代码提示等功能</p></blockquote><ul><li>安装所需扩展</li><li>输入代码按Tab或者Enter来实现代码补全</li></ul><h2 id="6-VS-Code-代码导航"><a href="#6-VS-Code-代码导航" class="headerlink" title="6 VS Code 代码导航"></a>6 VS Code 代码导航</h2><h3 id="6-1-快速文件导航"><a href="#6-1-快速文件导航" class="headerlink" title="6.1 快速文件导航"></a>6.1 快速文件导航</h3><blockquote><p>VS Code可以快速在文件之间进行导航</p></blockquote><ul><li><code>Ctrl+P</code>：快速打开文件</li><li><code>Ctrl+Tab</code>：已打开的文件中循环切换</li></ul><h3 id="6-2-跳转到文件定义处"><a href="#6-2-跳转到文件定义处" class="headerlink" title="6.2 跳转到文件定义处"></a>6.2 跳转到文件定义处</h3><ul><li><code>F12</code>：可以跳转到文件定义的地方，同：<code>Ctrl+Alt+Click</code></li><li><code>Ctrl+鼠标经过</code>：可以显示帮助信息，告诉我们文件定义的地方在哪里</li><li><code>Ctrl+Shift+O</code>：跳转到Symbol(方法或者变量)，如果文件很大，方法很多的时候可以使用它</li></ul><h3 id="6-3-Peek"><a href="#6-3-Peek" class="headerlink" title="6.3 Peek"></a>6.3 Peek</h3><ul><li><code>Shift+F12</code>：Peek可以嵌入在当前页面进行浏览，这样可以很方便，也可以右键点击选择Peek</li></ul><h3 id="6-4-括号匹配"><a href="#6-4-括号匹配" class="headerlink" title="6.4 括号匹配"></a>6.4 括号匹配</h3><ul><li><code>Ctrl+Shift+\</code>：如果一个方法内容很多，并且有很多方法，使用该快捷键，可以很容易的判断每一个方法的内容区域</li></ul><h2 id="7-VS-Code-代码重构"><a href="#7-VS-Code-代码重构" class="headerlink" title="7 VS Code 代码重构"></a>7 VS Code 代码重构</h2><blockquote><p>源代码重构可以通过重构代码而不用修改运行时行为来提高项目的质量和可维护性，VS Code支持重构操作，例如：Extract Method和Extract Varlable,以改善编辑器中的代码库</p></blockquote><h3 id="7-1-重构代码"><a href="#7-1-重构代码" class="headerlink" title="7.1 重构代码"></a>7.1 重构代码</h3><blockquote><p>重构代码，根据右键选择的不同内容，有不同的重构选择</p></blockquote><ul><li>选择一个完整的方法，可以重构到新的文件中</li><li><p>选择一个return的输出</p><ul><li>重构为一个内部的声明变量</li><li>重构为闭包</li><li>重构为全局变量</li></ul></li><li><p>等等….</p></li></ul><p>…重构有风险，忍住欲望，不要试图重构你不理解的代码。</p><h3 id="7-2-重命名symbol"><a href="#7-2-重命名symbol" class="headerlink" title="7.2 重命名symbol"></a>7.2 重命名symbol</h3><ul><li><code>F2</code>：可以选择符号，例如变量名，方法函数名等等，进行批量重命名</li></ul><h2 id="8-VS-Code-代码调试"><a href="#8-VS-Code-代码调试" class="headerlink" title="8 VS Code 代码调试"></a>8 VS Code 代码调试</h2><blockquote><p>VS Code的一个关键功能就是其出色的调试支持，VS Code的内置调试器有助于加速编辑，编译和调试循环</p></blockquote><h3 id="8-1-调试扩展"><a href="#8-1-调试扩展" class="headerlink" title="8.1 调试扩展"></a>8.1 调试扩展</h3><blockquote><p>VS Code具有对Node.js运行时的内置调制支持，可以调试JavaScript，TypeScript,TypeScript以及任何转换为JavaScript的语言，要调试其他语言和运行时(包括PHP,Ruby,Go,C#,Python,C++,Powershell等)，需要在VS扩展中查找安装调试器扩展。</p></blockquote><ul><li>如果涉及到其他语言，需安装附加调试器</li></ul><h3 id="8-2-添加断点"><a href="#8-2-添加断点" class="headerlink" title="8.2 添加断点"></a>8.2 添加断点</h3><blockquote><p>在编辑器代码区域最左端，点击添加断点</p></blockquote><h3 id="8-3-调试快捷键"><a href="#8-3-调试快捷键" class="headerlink" title="8.3 调试快捷键"></a>8.3 调试快捷键</h3><div class="table-container"><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>F5</td><td>继续/暂停</td></tr><tr><td>F10</td><td>跳过</td></tr><tr><td>F11</td><td>进入</td></tr><tr><td>Shift+F11</td><td>退出</td></tr><tr><td>Ctrl+Shift+F5</td><td>重新开始</td></tr><tr><td>Shift+F5</td><td>停止</td></tr></tbody></table></div><h2 id="9-VS-Code-集成终端"><a href="#9-VS-Code-集成终端" class="headerlink" title="9 VS Code 集成终端"></a>9 VS Code 集成终端</h2><blockquote><p>在Visual Studio Code中，您可以打开一个集成终端，最初从工作区的根目录开始，这可以非常方便，因为您不必切换窗口或更改现有终端的状态以执行快速命令行任务</p></blockquote><h3 id="9-1-打开终端视图"><a href="#9-1-打开终端视图" class="headerlink" title="9.1 打开终端视图"></a>9.1 打开终端视图</h3><ul><li>打开终端：Ctrl+` || view&gt;terminal 菜单 || 命令-&gt;Toggle Integrated Terminal</li><li>Ctrl+Shift+`：新建终端</li></ul><h3 id="9-2-管理多个终端"><a href="#9-2-管理多个终端" class="headerlink" title="9.2 管理多个终端"></a>9.2 管理多个终端</h3><ul><li>添加/删除多个终端</li></ul><h3 id="9-3-配置终端"><a href="#9-3-配置终端" class="headerlink" title="9.3 配置终端"></a>9.3 配置终端</h3><ul><li><p>终端类型,搜索 <code>terminal</code> 进行配置,具体的指向地址根基实际改变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Command Prompt</span></span><br><span class="line"><span class="string">"terminal.integrated.shell.windows"</span>: <span class="string">"C:\\Windows\\System32\\cmd.exe"</span></span><br><span class="line"><span class="comment">// PowerShell</span></span><br><span class="line"><span class="string">"terminal.integrated.shell.windows"</span>: <span class="string">"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe"</span></span><br><span class="line"><span class="comment">// Git Bash</span></span><br><span class="line"><span class="string">"terminal.integrated.shell.windows"</span>: <span class="string">"C:\\Program Files\\Git\\bin\\bash.exe"</span></span><br><span class="line"><span class="comment">// Bash on Ubuntu (on Windows)</span></span><br><span class="line"><span class="string">"terminal.integrated.shell.windows"</span>: <span class="string">"C:\\Windows\\System32\\bash.exe"</span></span><br></pre></td></tr></table></figure></li><li><p>终端样式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">terminal.integrated.fontFamily</span><br><span class="line">terminal.integrated.fontSize</span><br><span class="line">terminal.integrated.fontWeight</span><br><span class="line">terminal.integrated.fontWeightBold</span><br><span class="line">terminal.integrated.lineHeight</span><br></pre></td></tr></table></figure></li></ul><h2 id="10-VS-Code使用Emmet"><a href="#10-VS-Code使用Emmet" class="headerlink" title="10 VS Code使用Emmet"></a>10 VS Code使用Emmet</h2><blockquote><p>Emmet类似于CSS选择器的语法来描述元素在生成的树和元素属性中的位置。</p><p>Tab或Enter键触发</p></blockquote><h3 id="10-1-元素"><a href="#10-1-元素" class="headerlink" title="10.1 元素"></a>10.1 元素</h3><ul><li>可以直接使用元素的名字来快速生成Html标签</li><li>可以编写任何单词并将其转换为标签</li></ul><h3 id="10-2-嵌套运算符"><a href="#10-2-嵌套运算符" class="headerlink" title="10.2 嵌套运算符"></a>10.2 嵌套运算符</h3><blockquote><p>嵌套运算符用于在生成的树中定位缩写的元素</p></blockquote><ul><li><code>&gt;</code>：子元素<ul><li>可以使用<code>&gt;</code>运算符将元素嵌套在彼此内</li></ul></li><li><code>+</code>：兄弟元素<ul><li>可以使用<code>+</code>运算符将元素放在彼此的附近，在同一级别上</li></ul></li><li><code>^</code>：向上<ul><li>使用<code>^</code>运算符，可以爬到树的上一个级别</li></ul></li><li><code>*</code>：乘法<ul><li>使用<code>*</code>运算符，可以定义元素应该输出的次数</li></ul></li><li><code>（）</code>：分组<ul><li>使用<code>()</code>对复杂缩写中的子树进行分组</li></ul></li><li><code>[]</code>：定义属性<ul><li>以<code>[id=ab][name=abel]</code>的格式定义属性值</li></ul></li><li><code>{}</code>：定义内容<ul><li>在元素标签中定义内容</li><li><code>$</code>：代表累加，也可以运用在属性定义中。</li></ul></li></ul><h3 id="10-3-属性运算符"><a href="#10-3-属性运算符" class="headerlink" title="10.3 属性运算符"></a>10.3 属性运算符</h3><blockquote><p>属性运算符用于修改输出元素的属性</p></blockquote><ul><li><code>#id_name</code>：给元素添加id属性</li><li><code>.class_name</code>：给元素添加class属性</li></ul><h3 id="10-4-CSS缩写"><a href="#10-4-CSS缩写" class="headerlink" title="10.4 CSS缩写"></a>10.4 CSS缩写</h3><blockquote><p>对于CSS语法，Emmet有很多预定义的属性片段。</p><p>作用于Style区域中</p></blockquote><p>例如：</p><ul><li><p><code>m-10--20</code>：<code>margin: -10px -20px;</code></p></li><li><p><code>p20</code>：<code>padding: 20px;</code></p></li><li><code>h20</code>：<code>height: 20px;</code></li><li>……..</li></ul><h2 id="11-Vscode开发JavaScript"><a href="#11-Vscode开发JavaScript" class="headerlink" title="11 Vscode开发JavaScript"></a>11 Vscode开发JavaScript</h2><h3 id="11-1-智能跟踪"><a href="#11-1-智能跟踪" class="headerlink" title="11.1 智能跟踪"></a>11.1 智能跟踪</h3><ul><li>常见结构<ul><li>for</li><li>while</li><li>do while</li><li>if else</li><li>try/catch</li><li>…..</li></ul></li><li>代码提示</li><li>自动导入</li></ul><h3 id="11-2-文本注释"><a href="#11-2-文本注释" class="headerlink" title="11.2 文本注释"></a>11.2 文本注释</h3><ul><li><code>Ctrl+/</code>：注释 </li><li><code>Shift+Alt+A</code>：块注释</li></ul><h3 id="11-3-代码重构"><a href="#11-3-代码重构" class="headerlink" title="11.3 代码重构"></a>11.3 代码重构</h3><ul><li>提取函数</li><li>提取变量</li></ul><h2 id="12-VS-Code-创建markdown格式文件"><a href="#12-VS-Code-创建markdown格式文件" class="headerlink" title="12 VS Code 创建markdown格式文件"></a>12 VS Code 创建markdown格式文件</h2><h3 id="12-1-markdown扩展"><a href="#12-1-markdown扩展" class="headerlink" title="12.1 markdown扩展"></a>12.1 markdown扩展</h3><ul><li>Markdown All in One</li><li>Markdown Shortcuts</li></ul><h2 id="13-VS-Code-开发TypeScript"><a href="#13-VS-Code-开发TypeScript" class="headerlink" title="13 VS Code 开发TypeScript"></a>13 VS Code 开发TypeScript</h2><blockquote><p>TypeScript是JavaScript的类型超集，可以编译为纯JavaScript，它提供了类，模块和接口，可以帮助我们构建健壮的组件</p></blockquote><h3 id="13-1-安装TypeScript编辑器"><a href="#13-1-安装TypeScript编辑器" class="headerlink" title="13.1 安装TypeScript编辑器"></a>13.1 安装TypeScript编辑器</h3><ul><li><p>命令行安装: <code>npm install -g typescript</code></p></li><li><p>验证</p><ul><li><code>tsc --version</code></li><li><code>tsc --help</code></li></ul></li></ul><h3 id="13-2-创建-ts"><a href="#13-2-创建-ts" class="headerlink" title="13.2 创建.ts"></a>13.2 创建.ts</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Startup</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> main(): number &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过编译，我们可以将.ts文件转换为.js文件</p><ul><li>编译 <code>tsc 文件名.ts</code></li></ul><h3 id="13-3-创建ts项目"><a href="#13-3-创建ts项目" class="headerlink" title="13.3 创建ts项目"></a>13.3 创建ts项目</h3><ul><li><p>tsconfig.json配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"compilerOptions"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过 任务编译项目</p><ul><li><code>Ctrl+Shift+B</code>：Run Build Task</li></ul></li></ul><h2 id="1-扩展推荐"><a href="#1-扩展推荐" class="headerlink" title="1 扩展推荐"></a>1 扩展推荐</h2><blockquote><p>按需采纳</p></blockquote><ul><li>HTML Snippets</li><li>HTML CSS Support</li><li>intelliSense for CSS class names in HTML</li><li>HTMLHint</li><li>Beautify css/sass/scss/less</li><li><p>stylelint</p></li><li><p>color plcker</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具的使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex的学习与使用</title>
      <link href="/2020/05/07/vuex%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/05/07/vuex%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于vue-cli的关于VueX的练习</p></blockquote><h2 id="1-Vuex的核心概念"><a href="#1-Vuex的核心概念" class="headerlink" title="1 Vuex的核心概念"></a>1 Vuex的核心概念</h2><blockquote><p>Vuex中 的主要核心概念如下：</p></blockquote><ul><li>State：唯一数据源</li><li>Mutation：通过函数，改变数据源</li><li>Action：异步操作</li><li>Getter：类似于管道</li><li>modules: Vuex 允许我们将 store 分割成<strong>模块</strong></li></ul><h3 id="1-1-State"><a href="#1-1-State" class="headerlink" title="1.1 State"></a>1.1 State</h3><blockquote><p>State提供唯一的公共数据源，所有共享的数据都要统一放到State中进行存储</p></blockquote><h4 id="1-1-1-定义State"><a href="#1-1-1-定义State" class="headerlink" title="1.1.1 定义State"></a>1.1.1 定义State</h4><ul><li>创建store数据源，提供唯一公共数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="1-1-2-访问State中的数据"><a href="#1-1-2-访问State中的数据" class="headerlink" title="1.1.2 访问State中的数据"></a>1.1.2 访问State中的数据</h4><ul><li><p>组件访问State中数据的第一种方式</p><ul><li><blockquote><p>子组件通过this.$store访问数据</p></blockquote></li><li><p>组件直接通过this.$store访问数据</p><ul><li>基本格式：<code>this.$store.state.全局数据名称</code></li></ul></li></ul></li><li><p>组件访问State中数据的第二种方式</p><ul><li><blockquote><p>当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余，为了解决这个问题，我们可以使用mapState辅助函数帮助我们生成计算属性。</p></blockquote></li><li><p>从vuex中按需导入mapState函数</p><ul><li>导入mapState函数：<code>import { mapState } from &#39;vuex&#39;</code></li></ul></li><li><p>将全局数据， 映射为当前组件的计算属性</p><ul><li><p>映射为计算机属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">'count'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.count</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="1-2-Mutation"><a href="#1-2-Mutation" class="headerlink" title="1.2 Mutation"></a>1.2 Mutation</h3><blockquote><p>Mutation用于变更Store中的数据 </p></blockquote><h4 id="1-2-1-定义Mutation"><a href="#1-2-1-定义Mutation" class="headerlink" title="1.2.1 定义Mutation"></a>1.2.1 定义Mutation</h4><ul><li><p>只能通过mutation变更Store数据，不可以直接操作Store中的数据</p></li><li><p>通过这种方式虽然操作起来稍微繁琐一些，但是可以集中监控所有数据的变化</p><ul><li><p>定义Mutation</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutation: &#123;</span><br><span class="line">        <span class="comment">// 可以在触发mutations的时候传递参数</span></span><br><span class="line">        add(state) &#123;</span><br><span class="line">            <span class="comment">//变更状态</span></span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="1-2-2-调用mutations的方法"><a href="#1-2-2-调用mutations的方法" class="headerlink" title="1.2.2 调用mutations的方法"></a>1.2.2 调用mutations的方法</h4><blockquote><p>通过调用中心定义的mutations的方法，进而来改变数据，也只有mutations中的函数有权利修改state中的数据</p></blockquote><ul><li><p>触发mutations的第一种方法</p><ul><li><p>基本格式：<code>this.$store.commit(&#39;add&#39;)</code></p></li><li><p>在触发mutations时传递参数</p><ul><li><p>定义mutation</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        addN(state, step) &#123;</span><br><span class="line">            <span class="comment">//变更状态</span></span><br><span class="line">            state.count += step</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>触发mutation</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    handle2 () &#123;</span><br><span class="line">        <span class="comment">// 在调用commit函数</span></span><br><span class="line">        <span class="comment">// 触发 mutation 时携带参数</span></span><br><span class="line">        <span class="keyword">this</span>.$store.commit(<span class="string">'addN'</span>, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>触发mutations的第二种方式</p><ul><li><p>从vuex中按需导入 mapMutations 函数</p><ul><li>导入mapMutations函数：<code>import { mapMutations } from &#39;vuex&#39;</code></li></ul></li><li><p>将所需要的mutations函数，映射为当前组件的methods方法</p><ul><li><p>映射为methods方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">methosd: &#123;</span><br><span class="line">    ...mapMutations([<span class="string">'add'</span>, <span class="string">'addN'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>触发mutation</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实参中，只需要输入另外的，不在仓库中定义的值</span></span><br><span class="line"><span class="keyword">this</span>.add(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="1-3-Action"><a href="#1-3-Action" class="headerlink" title="1.3 Action"></a>1.3 Action</h3><blockquote><p> Action用于处理异步任务</p><p>如果通过异步操作改变数据，必须通过Action,而不能使用Mutation，但是在Action中还是要通过触发Mutation的方式间接变更数据</p></blockquote><h4 id="1-3-1-定义Action"><a href="#1-3-1-定义Action" class="headerlink" title="1.3.1 定义Action"></a>1.3.1 定义Action</h4><ul><li><p>在Action中定义异步函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="comment">// ...省略其他代码</span></span><br><span class="line">    mutations: &#123;</span><br><span class="line">        add(state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        <span class="comment">// 传入一个形参，用于调用commit等方法</span></span><br><span class="line">        addAsync(context) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 在action中，不能直接修改state中的数据，必须通过context.commit调用mutations中定义的函数</span></span><br><span class="line">                <span class="comment">// commit只能调用mutations中的函数</span></span><br><span class="line">                context.commit(<span class="string">'add'</span>)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-3-2-触发Action的方法"><a href="#1-3-2-触发Action的方法" class="headerlink" title="1.3.2 触发Action的方法"></a>1.3.2 触发Action的方法</h4><ul><li><p>触发actions的第一种方式</p><ul><li><p>基本格式：<code>this.$store.dispatch(&#39;addAsync &#39;)</code></p></li><li><p>在触发actions异步任务的时候传递参数</p><ul><li><p>定义action</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="comment">// ...省略其他代码</span></span><br><span class="line">    mutations: &#123;</span><br><span class="line">        addN(state, step) &#123;</span><br><span class="line">            state.count += step</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        addNAsync(context, step)&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            context.commit(<span class="string">'addN'</span>,step)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>触发action</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发actions的时候携带参数</span></span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'addNAsync'</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>触发actions的第二种方式</p><ul><li><p>从vuex中按需导入mapActions函数</p><ul><li>导入mapActions函数：<code>import { mapActions } from &#39;vuex&#39;</code></li></ul></li><li><p>通过导入的mapActions函数，将需要的actons函数，映射为当前组件的methods方法</p><ul><li><p>映射为methods方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">...mapActions([&#39;addNAsync&#39;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>触发actions</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实参中，只需要输入另外的，不在仓库中定义的值</span></span><br><span class="line"><span class="keyword">this</span>.addNAsync(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="1-4-Getter"><a href="#1-4-Getter" class="headerlink" title="1.4 Getter"></a>1.4 Getter</h3><blockquote><p>Getter用于对Store中的数据进行加工处理形成新的数据</p><p>Getter可以对Store总已有的数据进行加工处理之后形成新的数据，类似Vue的计算属性</p><p>Store中数据发生变化的时候，Getter的数据也会跟着变化</p></blockquote><h4 id="1-4-1-定义Getter"><a href="#1-4-1-定义Getter" class="headerlink" title="1.4.1 定义Getter"></a>1.4.1 定义Getter</h4><ul><li><p>在getters中定义加工函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getters : &#123;</span><br><span class="line">        showNum: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'当前最新的数量是['</span>+ state.count +<span class="string">']'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-4-2-使用getter的方法"><a href="#1-4-2-使用getter的方法" class="headerlink" title="1.4.2 使用getter的方法"></a>1.4.2 使用getter的方法</h4><ul><li><p>使用getter的第一种方法</p><ul><li>基本格式：<code>this.$store.getters.名称</code></li></ul></li><li><p>使用getter的第二种方式</p><ul><li><p>从vuex中按需导入mapGetters函数</p><ul><li>导入mapGetters函数：<code>import { mapGetters } from &#39;Vuex&#39;</code></li></ul></li><li><p>通过导入的mapGetters函数，将需要的getter函数，映射为当前组件的computed属性</p><ul><li><p>映射为computed属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapGetters([<span class="string">'showNum'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用getters</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.showNum</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="2-基于Vuex的小案例"><a href="#2-基于Vuex的小案例" class="headerlink" title="2 基于Vuex的小案例"></a>2 基于Vuex的小案例</h2><blockquote><p>Todos备忘录小案例</p></blockquote><h3 id="2-1-初始化项目"><a href="#2-1-初始化项目" class="headerlink" title="2.1 初始化项目"></a>2.1 初始化项目</h3><h4 id="2-1-1-基于vue-cli创建项目"><a href="#2-1-1-基于vue-cli创建项目" class="headerlink" title="2.1.1 基于vue cli创建项目"></a>2.1.1 基于vue cli创建项目</h4><ul><li>通过vue ui命令打开可视化面板<ul><li>必须的项目配置<ul><li>vuex</li></ul></li></ul></li></ul><h4 id="2-1-2-安装依赖"><a href="#2-1-2-安装依赖" class="headerlink" title="2.1.2 安装依赖"></a>2.1.2 安装依赖</h4><ul><li>安装vuex依赖包<ul><li>运行依赖<ul><li>axios</li><li>ant-design-vue</li></ul></li></ul></li></ul><h4 id="2-1-3-实现Todos基本布局"><a href="#2-1-3-实现Todos基本布局" class="headerlink" title="2.1.3 实现Todos基本布局"></a>2.1.3 实现Todos基本布局</h4><ul><li>基于已有的样式模板<ul><li>根据vue-todos文档修改内容</li></ul></li></ul><h4 id="2-1-4-示例"><a href="#2-1-4-示例" class="headerlink" title="2.1.4 示例"></a>2.1.4 示例</h4><ul><li><p>过程、备注见源码内容。</p></li><li><p>源码：<a href="https://github.com/Abell99/my_vuex_todos" target="_blank" rel="noopener">https://github.com/Abell99/my_vuex_todos</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo-GitHub建立的个人博客踩坑纪要</title>
      <link href="/2020/04/25/%E5%9F%BA%E4%BA%8EHexo-GitHub%E5%BB%BA%E7%AB%8B%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91%E7%BA%AA%E8%A6%81/"/>
      <url>/2020/04/25/%E5%9F%BA%E4%BA%8EHexo-GitHub%E5%BB%BA%E7%AB%8B%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91%E7%BA%AA%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<p>参考文章：</p><ul><li><a href="https://juejin.im/post/5e9b3e87e51d4546d439834a#heading-18" target="_blank" rel="noopener">彻底搞懂如何使用Hexo+GitHubPages搭建个人博客</a></li></ul><p>个人博客网站：</p><ul><li><a href="https://www.abel.run/" target="_blank" rel="noopener">https://www.abel.run/</a></li></ul><p>搭建前提准备：</p><ul><li>node环境</li><li>GitHub账号</li><li>安装有git，并配置了用户以及ssh密钥</li></ul><blockquote><p>大致流程为：</p><p>在GitHub上面初始化一个仓库，开放master主干为GitHub Pages的源文件，复制该仓库的ssh地址。在本地通过初始化hexo根目录，并安装所需依赖，配置_config.yml文件，安装hexo提供的上传插件，生成博客并上g传到GitHub上面</p></blockquote><h2 id="0-记录点不同"><a href="#0-记录点不同" class="headerlink" title="0.记录点不同"></a>0.记录点不同</h2><blockquote><p>大致的流程都在参考文章有了详细的描述，这里只记录自己根据参考文章实现的过程中遇到的一些小的坑</p></blockquote><h3 id="一-关于-config-yml的配置"><a href="#一-关于-config-yml的配置" class="headerlink" title="一.关于_config.yml的配置"></a>一.关于_config.yml的配置</h3><blockquote><p>这里只记录配置第一次博客上传的要点</p></blockquote><h4 id="1-上传地址的配置"><a href="#1-上传地址的配置" class="headerlink" title="1.上传地址的配置"></a>1.上传地址的配置</h4><blockquote><p>上传地址的配置关系着能否准确的连接仓库完成上传指令</p></blockquote><p>以下是我的上传配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:Abell99/Abell99.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h5 id="1-1repo的准确获取"><a href="#1-1repo的准确获取" class="headerlink" title="1.1repo的准确获取"></a>1.1repo的准确获取</h5><ul><li>找到目标仓库</li><li>使用ssh连接</li><li>复制上传地址</li></ul><p><img src="/2020/04/25/%E5%9F%BA%E4%BA%8EHexo-GitHub%E5%BB%BA%E7%AB%8B%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91%E7%BA%AA%E8%A6%81/2020042501.png" alt="复制上传地址"></p><h4 id="2-css样式的地址配置"><a href="#2-css样式的地址配置" class="headerlink" title="2.css样式的地址配置"></a>2.css样式的地址配置</h4><blockquote><p>因为上传到仓库后，引用地址发生改变，因此我们需要配置基准地址，以确保在上传至仓库后，css样式得以完整的显示</p></blockquote><p>以下是我的配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url: https:<span class="comment">//abell99.github.io</span></span><br><span class="line">root: <span class="regexp">/Abell99/</span></span><br></pre></td></tr></table></figure><p>细节：url为网址，root为仓库名，区分大小写，url地址最后不跟“/”，而root要使用“/”包住</p><p>注意：url,root并非必须设置成这样，可根据资源所在位置进行调整。</p><h5 id="2-1url地址的获取"><a href="#2-1url地址的获取" class="headerlink" title="2.1url地址的获取"></a>2.1url地址的获取</h5><p><img src="/2020/04/25/%E5%9F%BA%E4%BA%8EHexo-GitHub%E5%BB%BA%E7%AB%8B%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91%E7%BA%AA%E8%A6%81/2020042502.png" alt="精准获取url1"></p><p><img src="/2020/04/25/%E5%9F%BA%E4%BA%8EHexo-GitHub%E5%BB%BA%E7%AB%8B%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91%E7%BA%AA%E8%A6%81/2020042503.png" alt="精准获取url2"></p><ul><li>打开仓库设置界面</li><li>找到GitHub Pages下提供的url地址</li></ul><h3 id="二-新建文章以及图片显示问题"><a href="#二-新建文章以及图片显示问题" class="headerlink" title="二.新建文章以及图片显示问题"></a>二.新建文章以及图片显示问题</h3><blockquote><p>默认的新建文章是不配对应的图片文件的，需要安装插件</p></blockquote><h4 id="1-配置-config-yml"><a href="#1-配置-config-yml" class="headerlink" title="1.配置_config.yml"></a>1.配置_config.yml</h4><ul><li>post_asset_folder的值设为true</li></ul><h4 id="2-安装插件"><a href="#2-安装插件" class="headerlink" title="2.安装插件"></a>2.安装插件</h4><ul><li><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></li></ul><h4 id="3-修改插件内容"><a href="#3-修改插件内容" class="headerlink" title="3.修改插件内容"></a>3.修改插件内容</h4><ul><li>打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">'.'</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">'after_post_render'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.permalink;</span><br><span class="line"><span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line"><span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">'excerpt'</span>, <span class="string">'more'</span>, <span class="string">'content'</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">'img'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> ($(<span class="keyword">this</span>).attr(<span class="string">'src'</span>))&#123;</span><br><span class="line"><span class="comment">// For windows style path, we replace '\' to '/'.</span></span><br><span class="line"><span class="keyword">var</span> src = $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">   !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">  <span class="comment">// For "about" page, the first part of "src" can't be removed.</span></span><br><span class="line">  <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">  <span class="keyword">var</span> linkArray = link.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> elem != <span class="string">''</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> srcArray = src.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> elem != <span class="string">''</span> &amp;&amp; elem != <span class="string">'.'</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">srcArray.shift();</span><br><span class="line">  src = srcArray.join(<span class="string">'/'</span>);</span><br><span class="line">  $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>, config.root + link + src);</span><br><span class="line">  <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"update link as:--&gt;"</span>+config.root + link + src);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"no src attr, skipped..."</span>);</span><br><span class="line"><span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-引入方法"><a href="#4-引入方法" class="headerlink" title="4.引入方法"></a>4.引入方法</h4><p>图示文件地址目录结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如何在博客文档中插入图片</span><br><span class="line">---图片<span class="number">1.</span>jpg</span><br><span class="line">如何在博客文档中插入图片.md</span><br></pre></td></tr></table></figure><ul><li>使用<code>![描述文字](如何在博客文档中插入图片\图片1.jpg)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑纪要 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
